<?xml version="1.0" encoding="UTF-8"?>
<quiz xmlns="https://bigoquiz.com/document" format_version="1" id="graphs">
    <title>Graphs</title>

    <section id="terminology" answers_as_choices="true">
        <title>Terminology</title>
        <question id="terminology-undirected-graph">
            <text>Undirected Graph</text>
            <link>https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#Undirected_graph</link>
            <link></link>
            <answer>A graph whose edges are all bidirectional.</answer>
        </question>

        <question id="terminology-directed-graph">
            <text>Directed Graph (Digraph)</text>
            <link>https://en.wikipedia.org/wiki/Directed_graph</link>
            <answer>A graph whose edges go only in one direction.</answer>
        </question>

        <question id="terminology-dag">
            <text>Directed Acyclic Graph (DAG)</text>
            <link>https://en.wikipedia.org/wiki/Directed_acyclic_graph</link>
            <answer>A directed graph with no cycles.</answer>
        </question>

        <question id="terminology-adjacent-vertices">
            <text>Adjacent vertices</text>
            <answer>Vertices joined by an edge.</answer>
        </question>

        <question id="terminology-incident-edges">
            <text>Incident edges</text>
            <answer>Edges that share a vertex.</answer>
        </question>

        <question id="terminology-incident-vertex-of-edge">
            <text>Incident vertex of an edge</text>
            <answer>A vertex connected by the edge.</answer>
        </question>

        <question id="terminology-incident-edge-of-vertex">
            <text>Incident edge of a vertex</text>
            <answer>An edge connected to the vertex.</answer>
        </question>

        <question id="terminology-degree-of-vertex">
            <text>Degree of a vertex</text>
            <link>https://en.wikipedia.org/wiki/Degree_(graph_theory)</link>
            <answer>The number of edges incident to the vertex.</answer>
            <note>In undirected connected graphs, if there are 0 vertices with odd degree, there can be an Euler tour. If there are only 0 or 2 vertices with odd degree, there can be an Euler path.</note>
            <!-- See the Eulerian Path and Eulerian Cycle items for details about undirected graphs. -->
        </question>

        <question id="terminology-t-indegree-of-vertex">
            <text>Indegree of a vertex in a directed graph</text>
            <link>https://en.wikipedia.org/wiki/Degree_(graph_theory)</link>
            <answer>The number of edges leading to the vertex.</answer>
        </question>

        <question id="terminology-outdegree-of-vertex">
            <text>Outdegree of a vertex in a directed graph</text>
            <link>https://en.wikipedia.org/wiki/Degree_(graph_theory)</link>
            <answer>The number of edges leading from the vertex.</answer>
        </question>

        <question id="terminology-leaf-vertex">
            <text>Leaf Vertex (pendant vertex)</text>
            <link>https://en.wikipedia.org/wiki/Vertex_(graph_theory)#Types_of_vertices</link>
            <answer>Vertex with degree 1.</answer>
        </question>

        <question id="terminology-source-vertex">
            <text>Source Vertex</text>
            <link>https://en.wikipedia.org/wiki/Vertex_(graph_theory)#Types_of_vertices</link>
            <answer>Vertex with in degree 0.</answer>
        </question>

        <question id="terminology-sink-vertex">
            <text>Source Vertex</text>
            <link>https://en.wikipedia.org/wiki/Vertex_(graph_theory)#Types_of_vertices</link>
            <answer>Vertex with out degree 0.</answer>
        </question>

        <question id="terminology-simplicial-vertex">
            <text>Simplicial Vertex</text>
            <link>https://en.wikipedia.org/wiki/Vertex_(graph_theory)#Types_of_vertices</link>
            <answer>Vertex whose neighbours form a clique.</answer>
        </question>

        <question id="terminology-universal-vertex">
            <text>Universal Vertex</text>
            <link>https://en.wikipedia.org/wiki/Vertex_(graph_theory)#Types_of_vertices</link>
            <answer>Vertex that is adjacent to every other vertex.</answer>
        </question>

        <question id="terminology-dfs">
            <text>Depth First Search (DFS)</text>
            <link>https://en.wikipedia.org/wiki/Depth-first_search</link>
            <answer>Examine unexplored child vertices first, before examining sibling vertices.</answer>
        </question>

        <question id="terminology-bfs">
            <text>Breadth First Search (BFS)</text>
            <link>https://en.wikipedia.org/wiki/Breadth-first_search</link>
            <answer>Examine unexplored sibling vertices first, before examining child vertices.</answer>
        </question>

        <question id="terminology-transpose-graph">
            <text>Transpose Graph (Reverse Graph)</text>
            <link>https://en.wikipedia.org/wiki/Transpose_graph</link>
            <answer>A version of a directed graph, with each edge reversed.</answer>
        </question>

        <question id="terminology-kernel-dag">
            <text>Kernel DAG (condensation digraph)</text>
            <answer>A directed graph in which the strongly connected components are contracted to become single vertices.</answer>
        </question>

        <question id="terminology-simple-path">
            <text>Simple Path</text>
            <answer>A path with no repeated vertices - therefore, with no cycle.</answer>
        </question>

        <question id="terminology-multigraph">
            <text>Multigraph</text>
            <link>https://en.wikipedia.org/wiki/Multigraph</link>
            <answer>A graph with parallel edges.</answer>
            <note>Sometimes known as a pseudograph.</note>
        </question>

        <question id="terminology-hypergraph">
            <text>Hypergraph</text>
            <link>https://en.wikipedia.org/wiki/Hypergraph</link>
            <answer>A graph whose edges can connect more than 2 nodes.</answer>
        </question>

        <question id="terminology-articulation-point">
            <text>Articulation Point (Cut Vertex / Cut Point)</text>
            <link>https://en.wikipedia.org/wiki/Biconnected_component</link>
            <answer>A vertex whose removal disconnects the graph.</answer>
            <note>Removing the cut vertex increases the number of connected components.</note>
        </question>

        <question id="terminology-bridge">
            <text>Bridge (Cut Edge / Cut Arc)</text>
            <link>https://en.wikipedia.org/wiki/Bridge_(graph_theory)</link>
            <answer>An edge whose removal disconnects the graph.</answer>
            <note>Removing the cut edge increases the number of connected components.</note>
        </question>

        <question id="terminology-biconnected-graph">
            <text>Biconnected Graph (2-Connected Graph) </text>
            <link>https://en.wikipedia.org/wiki/Biconnected_graph</link>
            <answer>A connected graph which will remain connected if any one vertex is removed.</answer>
            <note>A biconnected graph has no articulation vertices (cut points).</note>
        </question>

        <question id="terminology-k-connected-graph">
            <text>K-Connected Graph (k-vertex-connected Graph) </text>
            <link>https://en.wikipedia.org/wiki/K-vertex-connected_graph</link>
            <answer>A connected graph which will remain connected if fewer than k vertices are removed.</answer>
            <note>A 2-connected graph is called biconnected. A 3-connected graph is called triconnected.</note>
        </question>

        <question id="terminology-biconnected-component">
            <text>Biconnected Component</text>
            <link>https://en.wikipedia.org/wiki/Biconnected_component</link>
            <answer>A maximal set of edges such that any two edges lie on a common simple cycle.</answer>
        </question>
    </section>

    <section id="polynomial-time-problems-definitions" answers_as_choices="true">
        <title>Definitions: Polynomial-Time Problems</title>
        <question id="definition-connected-components">
            <text>Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29</link>
            <answer>Subsets of the vertices in which every vertex is reachable from every other vertex and no other vertices are reachable.</answer>
        </question>

        <question id="definition-weakly-weakly-connected-components">
            <text>Weakly Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>Subsets of the vertices in a directed graph in which every vertex is reachable from every other vertex, if the edges are considered as undirected.</answer>
        </question>

        <question id="definition-strongly-strongly-connected-components">
            <text>Strongly Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Strongly_connected_component</link>
            <answer>Subsets of the vertices in a directed graph in which every vertex is reachable from every other vertex.</answer>
            <note>Strongly connected components must have cycles. A DAG of N nodes will have N strongly connected components.</note>
        </question>

        <question id="definition-topological-sorting">
            <text>Topological Sorting</text>
            <link>https://en.wikipedia.org/wiki/Topological_sorting</link>
            <answer>An ordering of the vertices such that each edge leads only forwards.</answer>
        </question>

        <question id="definition-minimum-spanning-tree">
            <text>Minimum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Minimum_spanning_tree</link>
            <answer>A tree that connects each vertex in an undirected graph, using a subset of edges of the minimum weight.</answer>
            <note>A minimum spanning tree is always a minimum bottleneck spanning tree, but a minimum bottleneck spanning tree is not necessarily a minimum spanning tree.</note> <!-- TODO: Explain why an MST is always an MBST. -->
        </question>
        <!-- TODO: Maximum Spanning Tree, Bottleneck, Cut Property -->

        <question id="definition-minimum-bottleneck-spanning-tree">
            <text>Minimum Bottleneck Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Minimum_bottleneck_spanning_tree</link>
            <answer>A spanning tree whose most expensive edge is as cheap as possible.</answer>
            <note>A minimum bottleneck spanning tree is not necessarily a minimum spanning tree, but a minimum spanning tree is always a minimum bottleneck spanning tree.</note>
        </question>

        <question id="definition-maximum-spanning-tree">
            <text>Maximum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Minimum_spanning_tree</link>
            <answer>A tree that connects each vertex in an undirected graph, using a subset of edges of the maximum weight.</answer>
            <note>This is the widest path in the tree. We can find the maximum spanning tree, by making the edge weights negative and then using an MST algorithm.</note>
        </question>

        <!-- An Arborescence is a bit like a spanning tree, but for directed graphs.
             So says Sedgewick on page 630. -->
        <question id="definition-minimum-cost-arborescence">
            <text>Minimum Cost Arborescence</text>
            <link>https://en.wikipedia.org/wiki/Arborescence_(graph_theory)</link>
            <answer>A subgraph that has a directed path from a specific root to every other vertex, using a subset of edges of the minimum weight.</answer>
        </question>

        <question id="definition-shortest-path">
            <text>Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem</link>
            <answer>The shortest path between two specific vertices.</answer>
        </question>

        <question id="definition-transitive-closure">
            <text>Transitive Closure</text>
            <link>https://en.wikipedia.org/wiki/Transitive_reduction</link>
            <answer>Adds direct edges to each vertex, leading to all reachable nodes, to easily answer reachability questions.</answer>
        </question>

        <question id="definition-transitive-reduction">
            <text>Transitive Reduction</text>
            <link>https://en.wikipedia.org/wiki/Transitive_reduction</link>
            <answer>Removes as many edges as possible, optionally also adding edges, while maintaining the same reachability from each vertex to other vertices.</answer>
        </question>

        <question id="definition-bipartite-matching">
            <text>Bipartite Matching</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29</link>
            <answer>Finds two sets of vertices in which every edge is in both sets.</answer>
        </question>

        <question id="definition-matching">
            <text>Matching</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29</link>
            <answer>The largest subset of edges in which each vertex has at most one of the edges.</answer>
        </question>

        <question id="definition-eulerian-path">
            <text>Eulerian Path</text>
            <link>https://en.wikipedia.org/wiki/Eulerian_path</link>
            <answer>A tour that visits each edge at least once.</answer>
            <note>For undirected graphs, only possible if it has 0 or 2 vertices with odd degree. For directed graphs, only possible if 0 or 1 vertices have an out degree - in degree difference of 1.</note>
        </question>

        <question id="definition-eulerian-cycle">
            <text>Eulerian Cycle (Euler Tour)</text>
            <link>https://en.wikipedia.org/wiki/Eulerian_path</link>
            <answer>A tour that visits each edge only once, returning to the start.</answer>
            <note>For undirected graphs, only possible if every vertex has even degree (even number of edges), meaning there are 0 vertices with odd degree. For directed graphs, only possible if every vertex has in degree equal to its out degree (same number of incoming edges as outgoing edges).</note>
        </question>

        <question id="definition-edge-connectivity">
            <text>Edge Connectivity</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>The smallest subset of edges whose deletion will disconnect the graph.</answer>
        </question>

        <question id="definition-vertex-connectivity">
            <text>Vertex Connectivity</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>The smallest subset of vertices whose deletion will disconnect the graph.</answer>
        </question>

        <question id="definition-max-flow">
            <text>Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Maximum_flow_problem</link>
            <answer>The maximum flow which can be sent from one specific vertex to another while respecting the maximum capacity of each edge.</answer>
        </question>

        <!-- Missed a couple of "draw nicely" ones out. -->

        <question id="definition-planarity-detection">
            <text>Planarity Detection and Embedding</text>
            <link>https://en.wikipedia.org/wiki/Planarity_testing</link>
            <answer>Arrange the vertices so no edges cross.</answer>
        </question>

    </section>

    <section id="hard-problems-definitions" answers_as_choices="true">
        <title>Definitions: Hard Problems</title>
        <question id="definition-clique">
            <text>Clique</text>
            <link>https://en.wikipedia.org/wiki/Clique_%28graph_theory%29</link>
            <answer>The largest subset of vertices that are all connected to each other by edges.</answer>
        </question>

        <question id="definition-independent-set">
            <text>Independent Set</text>
            <link>https://en.wikipedia.org/wiki/Independent_set_%28graph_theory%29</link>
            <answer>The largest subset of vertices for which, for each vertex, each edge leads to a vertex not in the subset.</answer>
        </question>

        <question id="definition-dominating-set">
            <text>Dominating Set</text>
            <link>https://en.wikipedia.org/wiki/Dominating_set</link>
            <answer>A subset of vertices for which every vertex not in the subset is adjacent to a vertex in the subset.</answer>
        </question>

        <question id="definition-vertex-cover">
            <text>Vertex Cover</text>
            <link>https://en.wikipedia.org/wiki/Vertex_cover</link>
            <answer>The smallest subset of vertices for which, for each vertex, each edge leads to at least one vertex of the subset.</answer>
        </question>

        <question id="definition-tsp">
            <text>Traveling Salesman Problem</text>
            <link>https://en.wikipedia.org/wiki/Travelling_salesman_problem</link>
            <answer>A cycle of minimum cost, visiting each vertex exactly once.</answer>
        </question>

        <question id="definition-hamiltonian-cycle">
            <text>Hamiltonian Cycle</text>
            <link>https://en.wikipedia.org/wiki/Hamiltonian_path</link>
            <answer>A tour that visits each vertex only once, returning to the start.</answer>
        </question>

        <question id="definition-hamiltonian-path">
            <text>Hamiltonian Path</text>
            <link>https://en.wikipedia.org/wiki/Hamiltonian_path</link>
            <answer>A tour that visits each vertex only once.</answer>
        </question>

        <question id="definition-graph-partition">
            <text>Graph Partition</text>
            <link>https://en.wikipedia.org/wiki/Graph_partition</link>
            <answer>A partition of the vertices into roughly equal-sized subsets with a certain maximum spanning edge cost.</answer>
        </question>

        <question id="definition-vertex-coloring">
            <text>Vertex Coloring</text>
            <link>https://en.wikipedia.org/wiki/Graph_partition</link>
            <answer>A coloring of each vertex in which no edge leads to the same color, using the minimum number of colors.</answer>
        </question>

        <question id="definition-edge-coloring">
            <text>Edge Coloring</text>
            <link>https://en.wikipedia.org/wiki/Edge_coloring</link>
            <answer>A coloring of each edge in which no vertex has an edge of the same color, using the minimum number of colors.</answer>
        </question>

        <question id="definition-graph-isomorphism">
            <text>Graph Isomorphism</text>
            <link>https://en.wikipedia.org/wiki/Graph_isomorphism</link>
            <answer>A mapping from one set of vertices to another, such that the sets are identical.</answer>
        </question>

        <question id="definition-steiner-tree">
            <text>Steiner Tree</text>
            <link>https://en.wikipedia.org/wiki/Steiner_tree_problem</link>
            <answer>The smallest tree connecting all vertices, adding intermediate vertices if necessary.</answer>
        </question>

        <question id="definition-feedback-edge-set">
            <text>Feedback Edge Set</text>
            <link>https://en.wikipedia.org/wiki/Feedback_vertex_set</link>
            <answer>The smallest set of edges whose removal results in no cycles existing.</answer>
        </question>

        <question id="definition-feedback-vertex-set">
            <text>Feedback Vertex Set</text>
            <link>https://en.wikipedia.org/wiki/Feedback_vertex_set</link>
            <answer>The smallest set of vertices whose removal results in no cycles existing.</answer>
        </question>
    </section>

    <section id="polynomial-or-np-complete" answers_as_choices="true">
        <title>Polynomial or NP-complete</title>
        <question id="polynomial-or-np-complete-connected-components">
            <text>Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-weakly-weakly-connected-components">
            <text>Weakly Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-strongly-strongly-connected-components">
            <text>Strongly Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Strongly_connected_component</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-topological-sorting">
            <text>Topological Sorting</text>
            <link>https://en.wikipedia.org/wiki/Topological_sorting</link>
            <answer>Polynomial (linear)</answer>
        </question>

        <question id="polynomial-or-np-complete-minimum-spanning-tree">
            <text>Minimum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Minimum_spanning_tree</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-shortest-path">
            <text>Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-shortest-simple-path">
            <text>Shortest Simple Path avoiding negative cycles</text>
            <!-- TODO: <link></link> -->
            <answer>NP-complete</answer>
            <!-- TODO: Or just NP-hard? -->
        </question>

        <question id="polynomial-or-np-complete-transitive-closure">
            <text>Transitive Closure</text>
            <link>https://en.wikipedia.org/wiki/Transitive_reduction</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-transitive-reduction">
            <text>Transitive Reduction</text>
            <link>https://en.wikipedia.org/wiki/Transitive_reduction</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-matching">
            <text>Matching</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-eulerian-path">
            <text>Eulerian Path</text>
            <link>https://en.wikipedia.org/wiki/Eulerian_path</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-eulerian-cycle">
            <text>Eulerian Cycle</text>
            <link>https://en.wikipedia.org/wiki/Eulerian_path</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-edge-connectivity">
            <text>Edge Connectivity</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-vertex-connectivity">
            <text>Vertex Connectivity</text>
            <link>https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-max-flow">
            <text>Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Maximum_flow_problem</link>
            <answer>Polynomial</answer>
        </question>

        <!-- Missed a couple of "draw nicely" ones out. -->

        <question id="polynomial-or-np-complete-planarity-detection">
            <text>Planarity Detection and Embedding</text>
            <link>https://en.wikipedia.org/wiki/Planarity_testing</link>
            <answer>Polynomial</answer>
        </question>

        <question id="polynomial-or-np-complete-clique">
            <text>Clique</text>
            <link>https://en.wikipedia.org/wiki/Clique_%28graph_theory%29</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-independent-set">
            <text>Independent Set</text>
            <link>https://en.wikipedia.org/wiki/Independent_set_%28graph_theory%29</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-dominating-set">
            <text>Dominating Set</text>
            <link>https://en.wikipedia.org/wiki/Dominating_set</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-vertex-cover">
            <text>Vertex Cover</text>
            <link>https://en.wikipedia.org/wiki/Vertex_cover</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-tsp">
            <text>Traveling Salesman Problem</text>
            <link>https://en.wikipedia.org/wiki/Travelling_salesman_problem</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-hamiltonian-cycle">
            <text>Hamiltonian Cycle</text>
            <link>https://en.wikipedia.org/wiki/Hamiltonian_path</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-hamiltonian-path">
            <text>Hamiltonian Path</text>
            <link>https://en.wikipedia.org/wiki/Hamiltonian_path</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-graph-partition">
            <text>Graph Partition</text>
            <link>https://en.wikipedia.org/wiki/Graph_partition</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-vertex-coloring">
            <text>Vertex Coloring</text>
            <link>https://en.wikipedia.org/wiki/Graph_partition</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-2-color-vertex-coloring">
            <text>2-Color Vertex Coloring</text>
            <link>https://en.wikipedia.org/wiki/Graph_coloring#Polynomial_time</link>
            <answer>Polynomial (linear)</answer>
            <note>If a graph can be colored with 2 colors then it is bipartite.</note>
        </question>

        <question id="polynomial-or-np-complete-edge-coloring">
            <text>Edge Coloring</text>
            <link>https://en.wikipedia.org/wiki/Edge_coloring</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-2-color-edge-coloring">
            <text>2-Color Edge Coloring</text>
            <link>https://en.wikipedia.org/wiki/Graph_coloring#Polynomial_time</link>
            <answer>Polynomial (linear)</answer>
            <note>If a graph can be colored with 2 colors then it is bipartite.</note>
        </question>

        <!-- Recognition of graph isomorphism is considered quasi-polymorphic, as of 2015,
        so don't bother with this until it's clearer.
        See https://en.wikipedia.org/wiki/Graph_isomorphism_problem

        <question id="polynomial-or-np-complete-graph-isomorphism">
            <text>Graph Isomorphism</text>
            <link>https://en.wikipedia.org/wiki/Graph_isomorphism</link>
            <answer>NP-complete</answer>
        </question>
        -->

        <question id="polynomial-or-np-complete-steiner-tree">
            <text>Steiner Tree</text>
            <link>https://en.wikipedia.org/wiki/Steiner_tree_problem</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-feedback-edge">
            <text>Feedback Edge / Vertex Set</text>
            <link>https://en.wikipedia.org/wiki/Feedback_vertex_set</link>
            <answer>NP-complete</answer>
        </question>

        <question id="polynomial-or-np-complete-longest-path">
            <text>Longest Path in a generic graph</text>
            <link>https://en.wikipedia.org/wiki/Longest_path_problem</link>
            <answer>NP-complete</answer>
            <!-- Note: It's a bit like the travelling salesman problem. -->
            <!-- Really it is NP-hard, but the decision problem (is there a path of length k) is NP-complete.) -->
        </question>

        <question id="polynomial-or-np-complete-longest-path-in-dag">
            <text>Longest Path in a directed acyclic graph (DAG)</text>
            <link>https://en.wikipedia.org/wiki/Longest_path_problem#Acyclic_graphs_and_critical_paths</link>
            <answer>Polynomial (linear)</answer>
            <note>By inverting the comparison in a shortest path algorithm. For instance, when examining the vertices in topological order.</note>
        </question>
        <!-- TODO: Longest simple weighted path (involving bitonic?) v. longest simple unweighted path. -->
        <!-- TODO: Mention the critical path method. Pages 663 and 666 of Sedgewick. -->
    </section>

    <section id="graph-algorithm-purposes-shortest-path" answers_as_choices="true">
        <title>Graph Algorithm Purposes: Shortest Path</title>

        <question id="purpose-bellman-ford">
            <text>Bellman-Ford Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</link>
            <answer>Single-Source Shortest Path (with negative edges).</answer>
            <note>Dijkstra's algorithm won't work with negative weights because it assumes that adding an edge always makes the path longer.</note>
            <!-- TODO: Bellman-Ford also allows distributed computation. -->
            <!-- TODO: Optimizations --> <!-- TODO: Uses: Internet Routing -->
            <!-- TODO: Can detect negative cycles, but cannot then find a shortest path. -->
        </question>

        <question id="purpose-floyd-warshall">
            <text>Floyd Warshall Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm</link>
            <answer>All Pairs Shortest Path, for dense graphs (with negative edges).</answer>
        </question>

        <question id="purpose-johnsons">
            <text>Johnson's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Johnson's_algorithm</link>
            <answer>All Pairs Shortest Path, for sparse graphs (with negative edges).</answer>
        </question>

        <question id="purpose-n-dijkstra">
            <text>n * Dijkstra's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Dijkstra's_algorithm</link>
            <answer>All Pairs Shortest Path, for sparse graphs (no negative edges).</answer>
        </question>
    </section>

    <section id="graph-algorithm-purposes-others" answers_as_choices="true">
        <title>Graph Algorithm Purposes: Others</title>
        <question id="purpose-prims">
            <text>Prim's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Prim's_algorithm</link>
            <answer>Minimum Spanning Tree, for dense graphs.</answer>
            <note>Prim's, O(|E| log(|V|)), is better than Kruskal's, O(|E| log(|E|)), for dense graphs (more edges than nodes), particularly when using a Fibonacci Heap rather than a simple binary heap: O(|E| + |V| log(|V|)).</note>
        </question>

        <question id="purpose-kruskals">
            <text>Kruskal's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Kruskal's_algorithm</link>
            <answer>Minimum Spanning Tree, for sparse graphs.</answer>
            <note>Prim's is better than Kruskal's for dense graphs (more edges than nodes) only when using, for instance, a Fibonacci Heap rather than a simple binary heap.</note>
        </question>

        <question id="purpose-ford-fulkerson">
            <text>Ford-Fulkerson (Edmonds-Karp) Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm</link>
            <answer>Maximum Flow (sparse graphs).</answer>i
        </question>

        <question id="purpose-dinic">
            <text>Dinic's Algorithm</text>
            <link>https://en.wikipedia.org/wiki/Dinic's_algorithm</link>
            <answer>Maximum Flow (sparse graphs).</answer>
        </question>

        <question id="purpose-push-relabel">
            <text>Push-Relabel Algorithm (Preflow-Push)</text>
            <link>https://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm</link>
            <answer>Maximum Flow (dense graphs).</answer>
        </question>
    </section>

    <section id="graph-algorithm-definitions-shortest-path" answers_as_choices="true" and_reverse="true">
        <title>Graph Algorithm Definitions: Shortest Path</title>
        <link>https://en.wikipedia.org/wiki/Shortest_path_problem</link>
        <question id="definition-dijkstras">
            <text>Dijkstra's Algorithm for Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Dijkstra's_algorithm</link>
            <answer>Choose the outgoing edge with the least total path cost, starting with a zero-cost edge to the start vertex. Look at the edge's destination vertex and store the total path costs (and, optionally, the predecessor) for each outgoing edge's vertex. Repeat until we reach the destination. Use, and update, a min heap (priority queue) to choose the outgoing edge with the lowest total cost.</answer>
            <note>This is usually implemented with a priority queue (heap) or, even better, a Fibonacci heap. This is like Prim's MST algorithm, but the relax step chooses the shortest path from the source, instead of the shortest edge from the tree. Use the inverse comparison to get the longest path.</note>
        </question>

        <question id="definition-bidirectional-dijkstra">
            <text>Dijkstra's Algorithm for Shortest Path (Bidirectional)</text>
            <link>https://en.wikipedia.org/wiki/Bidirectional_search</link> <!-- I learned this in: https://www.youtube.com/watch?v=CHvQ3q_gJ7E -->
            <answer>Alternate between forward search, from the source, and backward search from the destination. Terminate when the same vertex has been removed from the priority queue. Find the vertex with the minimum forward plus backward length.</answer>
        </question>

        <question id="definition-bellman-ford">
            <text>Bellman-Ford Algorithm for Single-Source Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</link>
            <answer>Start with 0 cost for the source vertex, and infinity for all other vertices. Then, for each vertex, examine each edge, to calculate the total path cost (or infinity) to reach the adjacent vertices, reducing the stored cost if it is less. Repeat the examination of edges, and the recalculation, n-1 times, or until there is no change. Do 1 extra iteration to detect negative cycles.</answer>
            <note>Alternatively, use a queue to examine only the vertices whose paths changed last time, checking regularly for negative cycles via DFS.</note>
        </question>

        <question id="definition-floyd-warshall">
            <text>Floyd Warshall Algorithm for All Pairs Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm</link>
            <answer>Examine every path from vertex i to vertex j, using at most k edges (using only vertices numbered from 1 to k), by examining i to j using k-1 edges (previously calculated) and examining i to k to j (i to k + k to j, both previously calculated) using at most k edges, passing through the additional kth vertex, using the minimum. To detect negative cycles, check for a negative cost from a node to itself.</answer>
        </question>

        <question id="definition-johnsons">
            <text>Johnson's Algorithm for All Pairs Shortest Path</text>
            <link>https://en.wikipedia.org/wiki/Johnson's_algorithm</link>
            <answer>Add one vertex to the graph, with zero-length edges to every other vertex. Run Bellman-Ford to get the shortest path from the new vertex to every other. Reweight the original graph's edges by adding the difference of the edge's start and end vertices' paths from s. Then call Dijkstra's algorithm for each pair of vertices, subtracting the reweighting difference from the result.</answer>
        </question>
    </section>

    <section id="graph-algorithm-definitions-mst" answers_as_choices="true" and_reverse="true">
        <title>Graph Algorithm Definitions: MST</title>
        <question id="definition-prims">
            <text>Prim's Algorithm for Minimum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Prim's_algorithm</link>
            <answer>Start with an arbitrary vertex. Find the lowest-cost outgoing edge and add its destination to the tree. Repeat until all vertices are in the tree.</answer>
            <note>This is usually implemented with a priority queue (heap), or even better, a Fibonacci Heap. This is like Dijkstra's shortest path algorithm, but the relax step chooses the shortest edge from the tree, instead of from the source. Use the inverse comparison to get a maximum spanning tree.</note>
        </question>

        <!-- Note: Kruskals is like a greedy algorithm for finding clusters, though that aborts early, to leave k clusters.
             https://www.coursera.org/learn/algorithm-design-analysis-2/lecture/QWubN/application-to-clustering  -->
        <question id="definition-kruskals">
            <text>Kruskal's Algorithm for Minimum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Kruskal's_algorithm</link>
            <answer>Iterate through all edges, in increasing order of their cost. Join each edge's vertices by adding them to a Union-Find (Disjoint Set), if they are not already joined, remembering the edges added.</answer>
        </question>
    </section>

    <section id="graph-algorithm-definitions-max-flow" answers_as_choices="true" and_reverse="true">
        <title>Graph Algorithm Definitions: Max Flow</title>
        <question id="definition-ford-fulkerson">
            <text>Ford-Fulkerson Algorithm for Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm</link>
            <answer>Define a residual graph with reverse edges. Find a path in that graph. Augment the path with its bottleneck capacity, decreasing capacity on used edges, increasing on reverse edges. Repeat until there is no path.</answer>
        </question>

        <question id="definition-dinic">
            <text>Dinic's Algorithm for Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Dinic's_algorithm</link>
            <answer>Ford-Fulkerson using BFS to find the path in each iteration.</answer>
        </question>

        <question id="definition-push-relabel">
            <text>Push-Relabel Algorithm for Maximum Flow (Preflow-Push)</text>
            <link>https://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm</link>
            <answer>Define a residual graph with reverse edges. Define heights for all vertices, starting with n for the source and 0 for others. Define excesses for each vertex. Starting with the source, repeatedly find the highest vertex that has excess and push flow along its downhill edges, increasing the excess on the edges' destination vertices. Repeat until there are no vertices with excess.</answer>
        </question>

        <!-- TODO: Kruskal's can be used to find clusters, stopping early. -->
        <!-- TODO: Uses: Floyd-Warshall: Transitive Closure of a binary relation. -->
    </section>

    <!-- This is much like a reverse of the graph-algorithm-purposes-shortest-path section,
      but with some useful rewording to really exercise understanding. -->
    <section id="graph-algorithm-choice-shortest-path" answers_as_choices="true" and_reverse="true">
        <title>Graph Algorithms Choice: Shortest path</title>
        <question id="algorithm-for-shortest-path-unweighted">
            <text>Single Source Shortest Path (unweighted)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem#Unweighted_graphs</link>
            <answer>Breadth First Search</answer>
        </question>

        <question id="algorithm-for-shortest-path-weighted-directed-acyclic">
            <text>Single Source Shortest Path (weighted, directed, acyclic - weighted DAG)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem#Directed_acyclic_graphs</link>
            <!-- http://www.geeksforgeeks.org/shortest-path-for-directed-acyclic-graphs/ -->
            <video_url>https://www.youtube.com/watch?v=ePqBaDRHkdk</video_url>
            <!-- Page 491 of TADM. -->
            <!-- TODO: O(|V| + |E|) -->
            <answer>Topological sort. Then Find minimum distance to adjacent nodes by examining nodes in topological order, starting with source, until destination.</answer>
        </question>

        <question id="algorithm-for-shortest-path-weighted-directed-non-negative-weights">
            <text>Single Source Shortest Path (weighted, directed, with non-negative weights)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem#Directed_graphs_with_nonnegative_weights</link>
            <answer>Dijkstra's algorithm</answer>
        </question>

        <question id="algorithm-for-shortest-path-weighted-directed-with-negative-weights">
            <text>Single Source Shortest Path (weighted, directed, with negative weights but no negative cycles)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem#Directed_graphs_with_arbitrary_weights_without_negative_cycles</link>
            <answer>Bellman-Ford algorithm</answer>
            <note>Dijkstra's algorithm won't work with negative weights because it assumes that adding an edge always makes the path longer.</note>
        </question>

        <question id="algorithm-for-all-pairs-shortest-path-with-non-negative-weights">
            <text>All Pairs Shortest Path (with non-negative weights)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem#All-pairs_shortest_paths</link>
            <answer>Floyd-Warshall (for dense graphs) or repeated Dijkstra's algorithm (for sparse graphs).</answer>
        </question>

        <question id="algorithm-for-all-pairs-shortest-path-with-negative-weights">
            <text>All Pairs Shortest Path (with negative weights but no negative cycles)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem#All-pairs_shortest_paths</link>
            <answer>Floyd-Warshall (for dense graphs) or Johnson's (for sparse graphs).</answer>
        </question>
    </section>

    <section id="graph-algorithm-choice-connected-components" answers_as_choices="true" and_reverse="true">
        <title>Graph Algorithms Choice: Connected Components</title>

        <question id="algorithm-for-connected-components">
            <text>Connected Components in an undirected graph</text>
            <link>https://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29</link>
            <answer>Depth First Search or Breadth First Search.</answer>
        </question>

        <question id="algorithm-for-weakly-connected-components">
            <text>Weakly Connected Components in a directed graph</text>
            <link>https://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29</link>
            <answer>Make edges undirected, then Depth First Search or Breadth First Search.</answer>
        </question>

        <question id="algorithm-for-stongly-connected-components">
            <text>Strongly Connected Components</text>
            <link>https://en.wikipedia.org/wiki/Strongly_connected_component</link>
            <answer>Kosaraju's Algorithm: Depth First Search on the reversed graph, to get a topological sort, then call DFS on each vertex in that order, assigning a new ID for each DFS call.</answer>
            <note>In the second DFS, pop from the first DFS's stack.</note>
            <!-- TODO: Sedgewick's Algorithms book says to DFS on the reversed graph first: https://www.youtube.com/watch?v=PH4L30XRhJE
            and Tim Roughgarden's course says this too: https://www.youtube.com/watch?v=PZQ0Pdk15RA
            but other descriptions DFS first on the real graph and then on a reversed graph. -->
        </question>
    </section>

    <section id="graph-algorithm-choice-others" answers_as_choices="true" and_reverse="true">
        <title>Graph Algorithms Choice: Others</title>

        <question id="algorithm-for-topological-sort">
            <text>Topological Sort</text>
            <link>https://en.wikipedia.org/wiki/Topological_sorting</link>
            <answer>Depth First Search to order vertices by their completion time, starting from each still unexplored vertex. Then reverse that order.</answer>
            <note>This is only possible on DAGs (Directed Acyclic Graphs). So there can't be a topological sort if the graph is undirected, or if the graph has a cycle. Find a cycle by checking for adjacent nodes that we have not completed (completed all children) with but are still exploring (still in the stack).</note>
        </question>

        <question id="algorithm-for-minimum-spanning-tree">
            <text>Minimum Spanning Tree</text>
            <link>https://en.wikipedia.org/wiki/Minimum_spanning_tree</link>
            <answer>Kruskal's, Prim's, or Boruvka's algorithm</answer>
        </question>

        <question id="algorithm-for-transitive-closure">
            <text>Transitive Closure</text>
            <link>https://en.wikipedia.org/wiki/Transitive_reduction</link>
            <answer>BFS or DFS, or modify Floyd-Warshall's algorithm to calculate only reachability.</answer>
        </question>

        <question id="algorithm-for-bipartite-matching-unweighted">
            <text>Bipartite Matching (unweighted)</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29#In_unweighted_bipartite_graphs</link>
            <answer>A Maximum Flow algorithm after adding source and sink vertices and setting all edge capacities to 1.</answer>
        </question>

        <question id="algorithm-for-bipartite-matching-weighted">
            <text>Bipartite Matching (weighted)</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29#In_weighted_bipartite_graphs</link>
            <answer>Hungarian Algorithm.</answer>
            <!-- TODO: Application to assignment problem. -->
        </question>

        <!-- TODO?
         <question id="algorithm-for-matching">
            <text>Graph Matching</text>
            <link>https://en.wikipedia.org/wiki/Matching_%28graph_theory%29</link>
            <answer>.</answer>
        </question>
        -->

        <question id="algorithm-for-maximum-flow">
            <text>Maximum Flow</text>
            <link>https://en.wikipedia.org/wiki/Maximum_flow_problem</link>
            <answer>Edmonds-Karp (Ford-Fulkerson), Dinic's, or Push-Relabel.</answer>
        </question>
    </section>

    <section id="graph-stack-or-queue" answers_as_choices="true" and_reverse="true">
        <title>Stack or Queue</title>

        <question id="stack-or-queue-bfs">
            <text>Breadth First Search iterative implementation</text>
            <link>https://en.wikipedia.org/wiki/Breadth-first_search</link>
            <answer>Queue</answer>
        </question>

        <question id="stack-or-queue-dfs">
            <text>Depth First Search iterative implementation</text>
            <link>https://en.wikipedia.org/wiki/Depth-first_search</link>
            <answer>Stack</answer>
            <note>Or via recursion, using the implicit call stack.</note>
        </question>
    </section>

    <section id="graph-directed-or-undirected" answers_as_choices="true" and_reverse="true">
        <title>For directed or undirected graphs</title>
        <question id="directed-or-undirected-shortest-path">
            <text>Shortest path (BFS, Dijkstra's, Bellman-Ford, Floyd Warshall, etc.)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem</link>
            <answer>Undirected or directed</answer>
        </question>

        <question id="directed-or-undirected-msp">
            <text>Minimum Spanning Tree (Prim's, Kruskal's, etc.)</text>
            <link>https://en.wikipedia.org/wiki/Minimum_spanning_tree</link>
            <answer>Undirected</answer>
        </question>
    </section>

    <section id="graph-bfs-or-dfs" answers_as_choices="true">
        <title>Breadth First Search (BFS) or Depth First Search (DFS)</title>
        <question id="bfs-or-dfs-shortest-path">
            <text>Single Source Shortest Path (unweighted)</text>
            <link>https://en.wikipedia.org/wiki/Shortest_path_problem#Unweighted_graphs</link>
            <answer>Breadth First Search</answer>
        </question>

        <question id="bfs-or-dfs-topological-sort">
            <text>Topological Sort</text>
            <link>https://en.wikipedia.org/wiki/Topological_sorting</link>
            <answer>Depth First Search</answer>
            <note>This is only possible on DAGs (Directed Acyclic Graphs)</note>
        </question>

        <question id="bfs-or-dfs-connected-components">
            <text>Connected Components in an undirected graph</text>
            <link>https://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29</link>
            <answer>Depth First Search or Breadth First Search</answer>
        </question>

        <question id="bfs-or-dfs-strongly-connected-components">
            <text>Strongly Connected Components in a directed graph</text>
            <link>https://en.wikipedia.org/wiki/Strongly_connected_component#Algorithms</link>
            <answer>Depth First Search</answer>
        </question>

        <question id="bfs-or-dfs-level-order">
            <text>Level-Order Traversal</text>
            <link>https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search</link>
            <answer>Breadth First Search</answer>
        </question>

        <question id="bfs-or-dfs-testing-bipartiteness">
            <text>Testing bipartiteness</text>
            <link>https://en.wikipedia.org/wiki/Bipartite_graph#Testing_bipartiteness</link>
            <answer>Depth First Search or Breadth First Search</answer>
        </question>
    </section>

    <section id="graph-dfs-edge-classifications" answers_as_choices="true" and_reverse="true">
        <title>Depth First Search: Edge Classifications</title>
        <link>https://en.wikipedia.org/wiki/Depth-first_search#Output_of_a_depth-first_search</link>

        <question id="graph-dfs-edge-classifications-tree">
            <text>Tree edge</text>
            <answer>An edge in the depth-first search, from a vertex to a later-discovered vertex.</answer>
        </question>

        <question id="graph-dfs-edge-classifications-back">
            <text>Back edge</text>
            <answer>A non-tree edge from a vertex to an ancestor.</answer>
            <note>A directed acyclic graph (DAG) has no back edges. So finding a back edge during a depth first search means we've found a cycle. A back edge points to a node we are currently exploring, whose exploration has not finished (marked as finished after the call stack unwinds).</note>
        </question>

        <question id="graph-dfs-edge-classifications-forward">
            <text>Forward edge</text>
            <answer>A non-tree edge from a vertex to a descendant.</answer>
        </question>

        <question id="graph-dfs-edge-classifications-cross">
            <text>Cross edge</text>
            <answer>All other edges, such as edges between vertices that are neither descendants nor ancestors of each other.</answer>
        </question>
    </section>

    <!-- TODO: This needs an example of a dense graph that occurs naturally,
    instead of being a subset of a sparse graph.
    Note: In sparse graphs, the number of edges increases linearly with the number of vertices.
    <section  id="graph-sparse-or-dense" answers_as_choices="true" >
        <title>Sparse or Dense Graphs</title>

        <question id="graph-sparse-or-dense-list">
            <text>Linked List</text>
            <answer>Sparse</answer>
        </question>

        <question id="graph-sparse-or-dense-tree">
            <text>Tree</text>
            <answer>Sparse</answer>
        </question>

        <question id="graph-sparse-or-dense-transport-network">
            <text>Transport network</text>
            <answer>Sparse</answer>
        </question>

        <question id="graph-sparse-or-dense-social-network">
            <text>Social network</text>
            <answer>Sparse</answer>
        </question>
    </section>
    -->

    <!-- Types of graph. This duplicates ideas from the algorithms needed to identify these graphs, but that is helpful.
    Planar. Hypergraph. Connected -->

    <!-- TODO: Examples:
      Hamiltonian Path: Open Knights Tour
      Hamiltonian Cycle: Closed Knights Tour
    -->
</quiz>
