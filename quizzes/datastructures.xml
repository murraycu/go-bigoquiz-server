<?xml version="1.0" encoding="UTF-8"?>
<quiz xmlns="https://bigoquiz.com/document" format_version="1" id="datastructures">
    <title>Data Structures</title>
    <section id="datastructures-abstract-data-types" answers_as_choices="true" and_reverse="true">
        <title>Abstract Data Types</title>
        <link>https://en.wikipedia.org/wiki/Abstract_data_type</link>

        <question id="datastructures-abstract-list">
            <text>Container</text>
            <link>https://en.wikipedia.org/wiki/Container_(abstract_data_type)</link>
            <answer>Abstract data type with a collection of objects.</answer>
        </question>

        <question id="datastructures-abstract-list">
            <text>List</text>
            <link>https://en.wikipedia.org/wiki/List_(abstract_data_type)</link>
            <answer>Abstract data type with an ordered sequence of values.</answer>
        </question>

        <question id="datastructures-abstract-set">
            <text>Set</text>
            <link>https://en.wikipedia.org/wiki/Set_(abstract_data_type)</link>
            <answer>Abstract data type with an unordered sequence of values without repeated values.</answer>
        </question>

        <question id="datastructures-abstract-multi set">
            <text>Multiset</text>
            <link>https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset</link>
            <answer>A set that allows repeated values or duplicates.</answer>
        </question>

        <question id="datastructures-abstract-multimap">
            <text>Map</text>
            <link>https://en.wikipedia.org/wiki/Associative_array</link>
            <answer>Abstract data type with a collection of keys and associated values.</answer>
        </question>

        <question id="datastructures-abstract-graph">
            <text>Graph</text>
            <link>https://en.wikipedia.org/wiki/Graph_(abstract_data_type)</link>
            <answer>Abstract data type with vertices and edges.</answer>
        </question>

        <question id="datastructures-abstract-stack">
            <text>Stack</text>
            <link>https://en.wikipedia.org/wiki/Stack_(abstract_data_type)</link>
            <answer>Abstract data type with push and pop in last-in-first-out (LIFO) order.</answer>
        </question>

        <question id="datastructures-abstract-queue">
            <text>Queue</text>
            <link>https://en.wikipedia.org/wiki/Queue_(abstract_data_type)</link>
            <answer>Abstract data type with push and pop in first-in-first-out (FIFO) order.</answer>
        </question>

        <question id="datastructures-abstract-priority-queue">
            <text>Priority Queue</text>
            <link>https://en.wikipedia.org/wiki/Heap_(data_structure)</link>
            <answer>Abstract data type that allows fast min (or max) retrieval. Usually implemented with a heap.</answer>
            <!-- Advantages of different implementations, including binary heap, binomial heap (easy merging), Fibonacci Heap (certain performance?), etc -->
            <!-- See https://en.wikipedia.org/wiki/Binomial_heap#Summary_of_running_times -->
        </question>

        <question id="datastructures-abstract-double-ended-queue">
            <text>Double-Ended Queue (Dequeue, Deque)</text>
            <link>https://en.wikipedia.org/wiki/Double-ended_queue</link>
            <answer>A queue allowing addition or removal from either end.</answer>
        </question>

        <question id="datastructures-abstract-double-ended-priority-queue">
            <text>Double-Ended Priority Queue (DEPQ)</text>
            <link>https://en.wikipedia.org/wiki/Double-ended_priority_queue</link>
            <answer>A priority queue allowing removal of both the min and max.</answer>
        </question>
    </section>

    <section id="datastructures-description" answers_as_choices="true" and_reverse="true">
        <title>Descriptions of Data Structures</title>

        <subsection id="datastructures-description-trees">
            <title>Trees</title>

            <question id="datastructures-description-tree">
                <text>Tree</text>
                <link>https://en.wikipedia.org/wiki/Tree_(data_structure)</link>
                <answer>Allows traversal of a tree of nodes.</answer>
            </question>

            <question id="datastructures-description-binary-search-tree">
                <text>Binary Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree</link>
                <answer>A tree whose child nodes are in sorted order, allowing binary search of the whole tree.</answer>
            </question>

            <question id="datastructures-description-self-balancing-binary-search-tree">
                <text>Self-Balancing Binary Search Tree (Balanced Binary Search Tree)</text>
                <link>https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree</link>
                <answer>A binary search tree that keeps its height small.</answer>
            </question>

            <question id="datastructures-description-optimal-binary-search-tree">
                <text>Optimal Binary Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Optimal_binary_search_tree</link>
                <answer>A binary search tree with the smallest possible search time for certain queries.</answer>
            </question>

            <question id="datastructures-description-binary-tree">
                <text>Binary Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_tree</link>
                <answer>A tree whose nodes have no more than 2 children.</answer>
            </question>

            <question id="datastructures-description-threaded-binary-tree">
                <text>Threaded Binary Tree</text>
                <link>https://en.wikipedia.org/wiki/Threaded_binary_tree</link>
                <answer>A binary tree in which normally-null left and right pointers lead to predecessors and successors.</answer>
            </question>

            <question id="datastructures-description-binomial-tree">
                <text>Binomial Tree</text>
                <link>https://en.wikipedia.org/wiki/Binomial_heap#Binomial_heap</link> <!-- Update if it gets its own wiki page. -->
                <answer>A tree in which a node of order k has children who are roots of trees of order k, k-1, ... 0. So each child's tree is deeper than its sibling child's tree. Permits easy merging of trees.</answer>
            </question>

            <question id="datastructures-description-b-tree">
                <text>B-Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_tree</link>
                <answer>A self-balancing tree in which each node can have multiple keys, separating multiple child nodes.</answer>
            </question>

            <question id="datastructures-description-2-3-tree">
                <text>2-3 Tree</text>
                <link>https://en.wikipedia.org/wiki/2%E2%80%933_tree</link>
                <answer>B-Tree of order 3.</answer>
            </question>

            <question id="datastructures-description-2-3-4-tree">
                <text>2-3-4 Tree</text>
                <link>https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree</link>
                <answer>B-Tree of order 4.</answer>
            </question>

            <question id="datastructures-description-avl-tree">
                <text>AVL Tree</text>
                <link>https://en.wikipedia.org/wiki/AVL_tree</link>
                <answer>A self-balancing binary search tree that, after an insert or deletion, rotates the lowest node whose child nodes' heights differ by more than 1.</answer>
            </question>

            <question id="datastructures-description-red-black-tree">
                <text>Red-Black Tree</text>
                <link>https://en.wikipedia.org/wiki/Red%E2%80%93black_tree</link>
                <answer>A self-balancing binary search tree that, after an insert or deletion, rotates the lowest nodes that do not satisfy the coloring constraints: Root is black. All leaves are black. All children of red nodes are black. All paths to leaves contain the same number of black nodes.</answer>
            </question>

            <question id="datastructures-description-cartesian-tree">
                <text>Cartesian Tree</text>
                <link>https://en.wikipedia.org/wiki/Cartesian_tree</link>
                <answer>A heap-ordered tree whose in-order traversal recreates the original sequence.</answer>
            </question>

            <question id="datastructures-description-trie">
                <text>Trie (Digital Tree, Prefix Tree)</text>
                <link>https://en.wikipedia.org/wiki/Trie</link>
                <answer>Stores all k prefixes of n strings.</answer>
            </question>

            <question id="datastructures-description-ternary-search-tree">
                <text>Ternary Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Ternary_search_tree</link>
                <answer>A trie that uses less space by having 3 BST-like branches at each node.</answer>
            </question>

            <question id="datastructures-description-radix-tree">
                <text>Radix Tree (Radix Trie, Compact Prefix Tree, Patricia Trie)</text>
                <link>https://en.wikipedia.org/wiki/Radix_tree</link>
                <answer>Space-optimized trie.</answer>
            </question>

            <!-- TODO: https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton -->

            <question id="datastructures-description-suffix-tree">
                <text>Suffix Tree</text>
                <link>https://en.wikipedia.org/wiki/Suffix_tree</link>
                <answer>Stores all k suffixes of n strings, allowing searches for all substrings.</answer>
            </question>

            <!-- TODO: Suffix array -->

            <question id="datastructures-description-van-emde-boas-tree">
                <text>Van Emde Boas Tree</text>
                <link>https://en.wikipedia.org/wiki/Van_Emde_Boas_tree</link>
                <answer>Associative array allowing fast O(lg lg N) successor/predecessor, and O(1) max/min, on keys of limited range N. by using a hierarchy of of clusters, each with a min and max.</answer>
            </question>

            <!-- See "How does Binary Indexed Tree work?" here: http://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/
            and Tushar Roy's walk-through, in the video_url. -->
            <question id="datastructures-description-binary-indexed-tree">
                <text>Binary Indexed Tree (Fenwick Tree)</text>
                <link>https://en.wikipedia.org/wiki/Fenwick_tree</link>
                <video_url>https://www.youtube.com/watch?v=CWDQJGaN1gY</video_url>
                <answer>Stores prefix sums (running totals). Has O(n log(n)) construction time, O(log(n)) update time, and O(log(n)) retrieval time.</answer>
            </question>
            <!-- Note: stores items-count per index, and optimized for "how many items are there between index m and n" queries.
            See https://stackoverflow.com/questions/17466218/what-are-the-differences-between-segment-trees-interval-trees-binary-indexed-t/17504505#17504505 -->

            <question id="datastructures-description-segment-tree">
                <text>Segment Tree</text>
                <link>https://en.wikipedia.org/wiki/Segment_tree</link>
                <answer>Stores intervals or segments and allows efficient searching for intervals that contain a certain point, or to query for a range sum or range minimum.</answer>
                <!-- TODO: Find a clear, but more general, description, without just mentioning the specific sum and minimum range queries. -->
                <video_url>https://youtu.be/ZBHKZF5w4YU</video_url>
            </question>

            <question id="datastructures-description-interval-tree">
                <text>Interval Tree</text>
                <link>https://en.wikipedia.org/wiki/Interval_tree</link>
                <answer>Stores intervals or segments and allows efficient searching for intervals that overlap a certain interval.</answer>
            </question>

            <question id="datastructures-description-range-tree">
                <text>Range Tree</text>
                <link>https://en.wikipedia.org/wiki/Range_tree</link>
                <answer>Allows efficient O((log n)^d + k) time searching for points that are within a certain interval. (Orthogonal Range Search). Particularly for searching in multiple dimensions. Using O(n(log n)^d-1) space.</answer>
            </question>

            <question id="datastructures-description-order-statistic-tree">
                <text>Order Statistic Tree</text>
                <link>https://en.wikipedia.org/wiki/Order_statistic_tree</link>
                <answer>Supports rank() and select() in O(log n) time.</answer>.
            </question>

            <question id="datastructures-description-finger-search-tree">
                <text>Finger Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Finger_search_tree</link>
                <answer>Allows fast search to nearby keys, in O(log(rank(x) - rank(y))) time.</answer>.
            </question>
        </subsection>

        <subsection id="datastructures-description-heaps">
            <title>Heaps</title>

            <question id="datastructures-description-heap">
                <text>Heap</text>
                <link>https://en.wikipedia.org/wiki/Heap_(data_structure)</link>
                <answer>A tree-based structure whose parent nodes are less (for a min heap) or greater (for a max heap) than their children, allowing fast min (or max) retrieval.</answer>
            </question>

            <question id="datastructures-description-binary-heap">
                <text>Binary Heap</text>
                <link>https://en.wikipedia.org/wiki/Binary_heap</link>
                <answer>A heap implemented with a binary tree, which is complete (all levels are filled, apart from leaves, which are filled from left to right.)</answer>
            </question>

            <question id="datastructures-description-binomial-heap">
                <text>Binomial Heap</text>
                <link>https://en.wikipedia.org/wiki/Binomial_heap</link>
                <answer>A mergeable heap, implemented as a collection of binomial trees.</answer>
            </question>

            <question id="datastructures-description-fibonacci-heap">
                <text>Fibonacci Heap</text>
                <link>https://en.wikipedia.org/wiki/Fibonacci_heap</link>
                <answer>A heap implemented as a collection of heaps, allowing fast decrease-key, delete, and merge.</answer>
            </question>

            <question id="datastructures-description-treap">
                <text>Treap</text>
                <link>https://en.wikipedia.org/wiki/Treap</link>
                <answer>A self-balancing binary search tree that is also a min (or max) heap in terms of a random weight for each node, resulting in a random binary search tree that is likely to be balanced.</answer>
            </question>
        </subsection>

        <subsection id="datastructures-description-others">
            <title>Others</title>

            <question id="datastructures-description-bloom-filter">
                <text>Bloom Filter</text>
                <link>https://en.wikipedia.org/wiki/Bloom_filter</link>
                <answer>Tests membership, with possibility of false positives.</answer>
            </question>

            <question id="datastructures-description-union-find">
                <text>Union Find (Disjoint Set)</text>
                <link>https://en.wikipedia.org/wiki/Disjoint-set_data_structure</link>
                <answer>Groups items into subsets.</answer>
            </question>

            <question id="datastructures-description-adjacency-list">
                <text>Adjacency List</text>
                <link>https://en.wikipedia.org/wiki/Adjacency_list</link>
                <answer>Lists nodes and their incident (often only outgoing) edges.</answer>
            </question>

            <question id="datastructures-description-adjacency-matrix">
                <text>Adjacency Matrix</text>
                <link>https://en.wikipedia.org/wiki/Adjacency_matrix</link>
                <answer>For any 2 nodes, provides the edge, if any, that connects them.</answer>
            </question>

            <question id="datastructures-description-singly-linked-list">
                <text>Singly Linked List</text>
                <link>https://en.wikipedia.org/wiki/Linked_list#Singly_linked_list</link>
                <answer>Allows forward traversal of the items in the list.</answer>
            </question>

            <question id="datastructures-description-doubly-linked-list">
                <text>Doubly Linked List</text>
                <link>https://en.wikipedia.org/wiki/Doubly_linked_list</link>
                <answer>Allows forward and backward traversal of the items in the list.</answer>
            </question>

            <question id="datastructures-description-hash-table">
                <text>Hash Table</text>
                <link>https://en.wikipedia.org/wiki/Hash_table</link>
                <answer>Maps keys to values using a hash function.</answer>
            </question>

            <question id="datastructures-description-skip-list">
                <text>Skip List</text>
                <link>https://en.wikipedia.org/wiki/Skip_list</link>
                <answer>A linked hierarchy of ordered elements, starting with the sparsest subsequence.</answer>
            </question>

            <question id="datastructures-description-splay-tree">
                <text>Splay Tree</text>
                <link>https://en.wikipedia.org/wiki/Splay_tree</link>
                <answer>Binary Search Tree that optimizes itself for recently accessed elements.</answer>
            </question>

            <question id="datastructures-description-k-d-tree">
                <text>k-d Tree</text>
                <link>https://en.wikipedia.org/wiki/K-d_tree</link>
                <answer>Allows proximity search in k-dimensional data by partitioning the space.</answer>
            </question>
        </subsection>
    </section>

    <section id="datastructures-implementations" and_reverse="true">
        <title>Implementations of Data Structures</title>

        <subsection id="datastructures-implementations-trees" answers_as_choices="true">
            <title>Trees</title>

            <question id="datastructures-implementation-tree">
                <text>Tree</text>
                <link>https://en.wikipedia.org/wiki/Tree_(data_structure)</link>
                <answer>Nodes with a data field and pointers to child nodes.</answer>
            </question>

            <question id="datastructures-implementation-binary-search-tree">
                <text>Binary Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree</link>
                <answer>Array or tree structure.</answer>
            </question>

            <question id="datastructures-implementation-self-balancing-binary-search-tree">
                <text>Self-Balancing Binary Search Tree (Balanced Binary Search Tree)</text>
                <link>https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree</link>
                <answer>Perform local rotation transformations after changes.</answer>
            </question>

            <question id="datastructures-implementation-optimal-binary-search-tree">
                <text>Optimal Binary Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Optimal_binary_search_tree</link>
                <answer>Construct initially and prevent modification, using dynamic programming. Or balance optimally (theoretically) after each modification.</answer>
            </question>

            <question id="datastructures-implementation-binary-tree">
                <text>Binary Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_tree</link>
                <answer>Nodes with a data field and pointers to only 2 child nodes.</answer>
            </question>

            <question id="datastructures-implementation-binomial-tree">
                <text>Binomial Tree</text>
                <link>https://en.wikipedia.org/wiki/Binomial_heap#Binomial_heap</link> <!-- Update if it gets its own wiki page. -->
                <answer>A tree in which a node of order k has children who are roots of trees of order k, k-1, ... 0. Construct by merging trees of same order, by adding the second tree as a child of the first tree's root.</answer>
            </question>

            <question id="datastructures-implementation-b-tree">
                <text>B-Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_tree</link>
                <answer>Nodes with multiple keys separating multiple child nodes. Nodes with d keys have d+1 child nodes.</answer>
            </question>

            <question id="datastructures-implementation-2-3-tree">
                <text>2-3 Tree</text>
                <link>https://en.wikipedia.org/wiki/2%E2%80%933_tree</link>
                <answer>B-Tree of order 3. Nodes with 1 or 2 keys separating 2 or 3 child nodes, respectively.</answer>
            </question>

            <question id="datastructures-implementation-2-3-4-tree">
                <text>2-3-4 Tree</text>
                <link>https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree</link>
                <answer>B-Tree of order 4. Nodes with 1, 2, or 3 keys separating 2, 3 or 4 child nodes, respectively.</answer>
            </question>

            <question id="datastructures-implementation-avl-tree">
                <text>AVL Tree</text>
                <link>https://en.wikipedia.org/wiki/AVL_tree</link>
                <answer>After an insert or deletion, rotates the lowest node whose child nodes' heights differ by more than 1.</answer>
            </question>

            <question id="datastructures-implementation-red-black-tree">
                <text>Red-Black Tree</text>
                <link>https://en.wikipedia.org/wiki/Red%E2%80%93black_tree</link>
                <answer>After an insert or deletion, rotates the lowest nodes that do not satisfy the coloring constraints: Root is black. All leaves are black. All children of red nodes are black. All paths to leaves contain the same number of black nodes.</answer>
            </question>

            <question id="datastructures-implementation-cartesian-tree">
                <text>Cartesian Tree</text>
                <link>https://en.wikipedia.org/wiki/Cartesian_tree#Efficient_construction</link>
                <answer>Construct the tree in (amortized) O(n) time by adding each node to the previous node, walking up the tree and splitting an edge if necessary, making children into left nodes.</answer>
            </question>

            <question id="datastructures-implementation-trie">
                <text>Trie (Digital Tree, Prefix Tree)</text>
                <link>https://en.wikipedia.org/wiki/Trie</link>
                <answer>Keys are defined by their position in the tree, with each edge being the next character (or bit) of the key, and with values associated with leaf nodes.</answer>
            </question>

            <question id="datastructures-implementation-ternary-search-tree">
                <text>Ternary Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Ternary_search_tree</link>
                <answer>Keys are defined by their position in the tree, with each node having a character and three links to nodes for the subsequent character - either a lesser, greater, or equal character.</answer>
            </question>

            <question id="datastructures-implementation-radix-tree">
                <text>Radix Tree (Radix Trie, Compact Prefix Tree)</text>
                <link>https://en.wikipedia.org/wiki/Radix_tree</link>
                <answer>Keys are defined by their position in the tree, with each edge being the next chunk of the key, and with values associated with leaf nodes.</answer>
            </question>

            <question id="datastructures-implementation-suffix-tree">
                <text>Suffix Tree</text>
                <link>https://en.wikipedia.org/wiki/Suffix_tree</link>
                <answer>Compressed Trie, with text suffixes as keys and text positions as values.</answer>
            </question>

            <question id="datastructures-implementation-van-emde-boas-tree">
                <text>Van Emde Boas Tree</text>
                <link>https://en.wikipedia.org/wiki/Van_Emde_Boas_tree</link>
                <answer>A hierarchy of of clusters that summarize less sparse clusters, each with a min and max.</answer>
            </question>

            <question id="datastructures-implementation-binary-indexed-tree">
                <text>Binary Indexed Tree (Fenwick Tree)</text>
                <link>https://en.wikipedia.org/wiki/Fenwick_tree</link>
                <answer>Array in which the index of child, parent, and next nodes are calculated using bitwise operations. The prefix sum is the sum of the node and its parent nodes.</answer>
            </question>

            <question id="datastructures-implementation-segment-tree">
                <text>Segment Tree</text>
                <link>https://en.wikipedia.org/wiki/Segment_tree</link>
                <video_url>https://www.youtube.com/watch?v=ZBHKZF5w4YU</video_url>
                <answer>Store the node values as an array, as in a binary heap, using the start of the range as the node's key. Each node summarizes its child nodes.</answer>
                <!-- TODO: Find a clear, but more general, description, without just mentioning the specific sum and minimum range queries. -->
                <!-- TODO: Describe the recursion properly, ideally not just for a range minimum query. -->
            </question>

            <question id="datastructures-implementation-interval-tree">
                <text>Interval Tree</text>
                <link>https://en.wikipedia.org/wiki/Interval_tree</link>
                <answer>A ternary tree, in which each node has a center point and links to nodes whose intervals are completely before or completely after the interval, as well as lists of overlapping intervals, in order of their start, and in order of their end.
Or alternatively, a (balanced) binary tree with intervals in each node, using the interval's start as the key. Each node is augmented with the maximum interval end for itself and its children.</answer>
            </question>
            <!-- This is the CLRS description, though not the primary one on wikipedia:
            https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree
            Sedgewick suggests the alternative: https://www.youtube.com/watch?v=f4mXJGEKBaA-->

            <question id="datastructures-implementation-range-tree">
                <text>Range Tree</text>
                <link>https://en.wikipedia.org/wiki/Range_tree</link>
                <answer>A complete balanced binary tree with points in the nodes. Examine right parents of the start and left parents of the end, listing all the parent nodes, and their subtrees, to the right of the start and to the left of the end. Each subtree has a range tree of the points by another dimension.</answer>
                <note>Range trees have faster query times than k-d trees, but use more space.</note>
                <video_url>https://www.youtube.com/watch?v=xVka6z1hu-I</video_url>
            </question>
            <!-- https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-notes/MIT6_046JS15_lec09.pdf
            -->
            <!-- TODO: Is this an inorder traversal from start to end? -->

            <question id="datastructures-implementation-order-statistic-tree">
                <text>Order Statistic Tree</text>
                <link>https://en.wikipedia.org/wiki/Order_statistic_tree</link>
                <answer>Augment a (balanced) binary search tree, maintaining the size of each node's subtree in the node.</answer>.
            </question>

            <question id="datastructures-implementation-finger-search-tree">
                <text>Finger Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Finger_search_tree</link>
                <answer>A level-linked 2-3 tree in which each node has links to next and previous nodes on the same level, and each node maintains the min and max in its subtree.</answer>.
            </question>
            <video_url>https://www.youtube.com/watch?v=xVka6z1hu-I</video_url>
        </subsection>

        <subsection id="datastructures-implementations-others" answers_as_choices="true">
            <title>Others</title>

            <question id="datastructures-implementation-bloom-filter">
                <text>Bloom Filter</text>
                <link>https://en.wikipedia.org/wiki/Bloom_filter</link>
                <answer>A bit array and a set of hash functions to map keys to positions.</answer>
            </question>

            <question id="datastructures-implementation-union-find">
                <text>Union Find (Disjoint Set)</text>
                <link>https://en.wikipedia.org/wiki/Disjoint-set_data_structure</link>
                <answer>A tree-based data structure, for instance in an array. Each position's value is the position of its parent.</answer>
            </question>

            <question id="datastructures-implementation-adjacency-list">
                <text>Adjacency List</text>
                <link>https://en.wikipedia.org/wiki/Adjacency_list</link>
                <answer>A list of each node and its edges.</answer>
            </question>

            <question id="datastructures-implementation-adjacency-matrix">
                <text>Adjacency Matrix</text>
                <link>https://en.wikipedia.org/wiki/Adjacency_matrix</link>
                <answer>A 2-dimensional array of node connections.</answer>
            </question>

            <question id="datastructures-implementation-singly-linked-list">
                <text>Singly Linked List</text>
                <link>https://en.wikipedia.org/wiki/Linked_list#Singly_linked_list</link>
                <answer>Nodes with a data field and a pointer to the next node.</answer>
            </question>

            <question id="datastructures-implementation-doubly-linked-list">
                <text>Doubly Linked List</text>
                <link>https://en.wikipedia.org/wiki/Doubly_linked_list</link>
                <answer>Nodes with a data field and both a pointer to the next node and a pointer to the previous node.</answer>
            </question>

            <question id="datastructures-implementation-hash-table">
                <text>Hash Table</text>
                <link>https://en.wikipedia.org/wiki/Hash_table</link>
                <answer>A hash function that maps keys to buckets in an array, resolving collisions either by Separate Chaining (linked list of items in each bucket) or Open Addressing (items stored in next available bucket).</answer>
            </question>

            <question id="datastructures-implementation-skip-list">
                <text>Skip List</text>
                <link>https://en.wikipedia.org/wiki/Skip_list</link>
                <answer>A linked hierarchy of ordered elements, starting with the sparsest subsequence.</answer>
            </question>

            <question id="datastructures-implementation-splay-tree">
                <text>Splay Tree</text>
                <link>https://en.wikipedia.org/wiki/Splay_tree</link>
                <answer>A binary search tree. After insertion, deletion, or searching, the node is rotated to become the root.</answer>
            </question>

            <question id="datastructures-implementation-k-d-tree">
                <text>k-d Tree</text>
                <link>https://en.wikipedia.org/wiki/K-d_tree</link>
                <answer>A binary tree. Each node defines a hyperplane and its left and right children are either side of that hyperplane. Typically the hyperplane will be chosen by cycling through the axes as we move down the tree. Each node is the median of the points in its subtree.</answer>
                <note>k-d trees use less space than range-trees, but have slower query times.</note>
            </question>
        </subsection>

        <subsection id="datastructures-implementations-heaps" answers_as_choices="true">
            <title>Heaps</title>

            <question id="datastructures-implementation-heap">
                <text>Heap</text>
                <link>https://en.wikipedia.org/wiki/Heap_(data_structure)</link>
                <answer>Usually implemented with an array. The K children of position i are from Ki+1 to Ki+K.</answer>
                <!-- TODO: Why does this mention k children instead of 2 children? -->
            </question>

            <!-- TODO: How is it kept complete? -->
            <question id="datastructures-implementation-binary-heap">
                <text>Binary Heap</text>
                <link>https://en.wikipedia.org/wiki/Binary_heap</link>
                <answer>Usually implemented with an array. The children of position i are at 2i+1 and 2i+2.</answer>
            </question>

            <question id="datastructures-implementation-binomial-heap">
                <text>Binomial Heap</text>
                <link>https://en.wikipedia.org/wiki/Binomial_heap</link>
                <answer>Store the roots of the binomial trees in an ordered list. Find minimum by finding the minimum root. Merge trees by making the larger root a child of the smaller root.</answer>
            </question>

            <!-- TODO: Binomial heap takes O(log n) time in all operations while Fibonacci heap takes amortized running time O(1) in Insert, find, decrease key operations and O(log n) time in delete min, delete operations. -->
            <!-- TODO: every Binomial heap is a Fibonacci heap but every Fibonacci heap isn't Binomial heap. -->
            <question id="datastructures-implementation-fibonacci-heap">
                <text>Fibonacci Heap</text>
                <link>https://en.wikipedia.org/wiki/Fibonacci_heap</link> <!-- This is good: http://www.growingwiththeweb.com/2014/06/fibonacci-heap.html -->
                <answer>A collection of heap-ordered trees, which are like binomial trees, but do not need to be restructured upon node removal. Each node has a doubly-linked list of its children. The roots of the trees are in a circular doubly-linked list. Nodes are marked when restructuring is necessary but that cleanup operations are deferred.</answer>
            </question>

            <question id="datastructures-implementation-treap">
                <text>Treap</text>
                <link>https://en.wikipedia.org/wiki/Treap</link>
                <answer>A cartesian tree that satisfies the heap property for random weights. Insert as per node value order and then rotate to maintain heap property for the random weight.</answer>
            </question>
        </subsection>
    </section>

    <section id="datastructures-uses" answers_as_choices="true" and_reverse="true">
        <title>Uses of Data Structures</title>

            <question id="datastructures-uses-queue">
                <text>Queue</text>
                <link>https://en.wikipedia.org/wiki/Queue_(abstract_data_type)</link>
                <answer>Breadth First Search</answer>
            </question>

            <question id="datastructures-uses-stack">
                <text>Stack</text>
                <link>https://en.wikipedia.org/wiki/Stack_(abstract_data_type)</link>
                <answer>Depth First Search. Expression parsing. Backtracking.</answer>
            </question>

            <!-- TODO?
            <question id="datastructures-uses-tree">
                <text>Tree</text>
                <link>https://en.wikipedia.org/wiki/Tree_(data_structure)</link>
                <answer>Allows traversal of a tree of nodes.</answer>
            </question>

            <question id="datastructures-uses-binary-search-tree">
                <text>Binary Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree</link>
                <answer>A tree whose child nodes are in sorted order, allowing binary search of the whole tree.</answer>
            </question>
            -->

            <question id="datastructures-uses-self-balancing-binary-search-tree">
                <text>Self-Balancing Binary Search Tree (Balanced Binary Search Tree)</text>
                <link>https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree</link>
                <answer>Key-value association. std::map.</answer>
                <!-- Advantages to hash_table. Use in computational geometry. -->
            </question>

            <question id="datastructures-uses-optimal-binary-search-tree">
                <text>Optimal Binary Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Optimal_binary_search_tree</link>
                <answer>Optimal searching of a static set of data.</answer>
            </question>

            <!--

            <question id="datastructures-uses-binary-tree">
                <text>Binary Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_tree</link>
                <answer>A tree whose nodes have no more than 2 children.</answer>
            </question>

            <question id="datastructures-uses-binomial-tree">
                <text>Binomial Tree</text>
                <link>https://en.wikipedia.org/wiki/Binomial_heap#Binomial_heap</link>
                <answer>A tree in which a node of order k has children who are roots of trees of order k, k-1, ... 0. So each child's tree is deeper than its sibling child's tree. Permits easy merging of trees.</answer>
            </question>
            -->

            <question id="datastructures-uses-b-tree">
                <text>B-Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_tree</link>
                <answer>On-disk databases.</answer>
            </question>

            <!--
            <question id="datastructures-uses-2-3-tree">
                <text>2-3 Tree</text>
                <link>https://en.wikipedia.org/wiki/2%E2%80%933_tree</link>
                <answer>B-Tree of order 3.</answer>
            </question>

            <question id="datastructures-uses-2-3-4-tree">
                <text>2-3-4 Tree</text>
                <link>https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree</link>
                <answer>B-Tree of order 4.</answer>
            </question>
            -->

            <!-- Don't bother mentioning uses of these as well as uses of generic
                 self-balancing binary search trees.
            <question id="datastructures-uses-avl-tree">
                <text>AVL Tree</text>
                <link>https://en.wikipedia.org/wiki/AVL_tree</link>
                <answer>A self-balancing binary search tree that, after an insert or deletion, rotates the lowest node whose child nodes' heights differ by more than 1.</answer>
            </question>

            <question id="datastructures-uses-red-black-tree">
                <text>Red-Black Tree</text>
                <link>https://en.wikipedia.org/wiki/Red%E2%80%93black_tree</link>
                <answer>A self-balancing binary search tree that, after an insert or deletion, rotates the lowest nodes that do not satisfy the coloring constraints: Root is black. All leaves are black. All children of red nodes are black. All paths to leaves contain the same number of black nodes.</answer>
            </question>
            -->

            <!--
            <question id="datastructures-uses-cartesian-tree">
                <text>Cartesian Tree</text>
                <link>https://en.wikipedia.org/wiki/Cartesian_tree</link>
                <answer>A heap-ordered tree whose in-order traversal recreates the original sequence.</answer>
            </question>

            <question id="datastructures-uses-trie">
                <text>Trie (Digital Tree, Prefix Tree)</text>
                <link>https://en.wikipedia.org/wiki/Trie</link>
                <answer>Stores all k prefixes of n strings.</answer>
            </question>

            <question id="datastructures-uses-ternary-search-tree">
                <text>Ternary Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Ternary_search_tree</link>
                <answer>A trie that uses less space by having 3 BST-like branches at each node.</answer>
            </question>

            <question id="datastructures-uses-radix-tree">
                <text>Radix Tree (Radix Trie, Compact Prefix Tree, Patricia Trie)</text>
                <link>https://en.wikipedia.org/wiki/Radix_tree</link>
                <answer>Space-optimized trie.</answer>
            </question>
            -->

            <question id="datastructures-uses-suffix-tree">
                <text>Suffix Tree</text>
                <link>https://en.wikipedia.org/wiki/Suffix_tree</link>
                <answer>Full text search. Matching genes in DNA. Longest Repeated Substring. Longest Common Substring.</answer>
            </question>

            <!-- TODO

            <question id="datastructures-uses-van-emde-boas-tree">
                <text>Van Emde Boas Tree</text>
                <link>https://en.wikipedia.org/wiki/Van_Emde_Boas_tree</link>
                <answer>Associative array allowing fast O(lg lg N) successor/predecessor, and O(1) max/min, on keys of limited range N. by using a hierarchy of of clusters, each with a min and max.</answer>
            </question>
            -->

            <question id="datastructures-uses-binary-indexed-tree">
                <text>Binary Indexed Tree (Fenwick Tree)</text>
                <link>https://en.wikipedia.org/wiki/Fenwick_tree</link>
                <answer>Arithmetic coding algorithm. Maintaining a cumulative sum (prefix sums).</answer>
            </question>

             <!--
            <question id="datastructures-uses-segment-tree">
                <text>Segment Tree</text>
                <link>https://en.wikipedia.org/wiki/Segment_tree</link>
                <answer>Stores intervals or segments and allows efficient searching for intervals that contain a certain point, or to query for a range sum or range minimum.</answer>
            </question>

            <question id="datastructures-uses-interval-tree">
                <text>Interval Tree</text>
                <link>https://en.wikipedia.org/wiki/Interval_tree</link>
                <answer>Stores intervals or segments and allows efficient searching for intervals that overlap a certain interval.</answer>
            </question>

            <question id="datastructures-uses-range-tree">
                <text>Range Tree</text>
                <link>https://en.wikipedia.org/wiki/Range_tree</link>
                <answer>Allows efficient O((log n)^d + k) time searching for points that are within a certain interval. (Orthogonal Range Search). Particularly for searching in multiple dimensions. Using O(n(log n)^d-1) space.</answer>
            </question>

            <question id="datastructures-uses-order-statistic-tree">
                <text>Order Statistic Tree</text>
                <link>https://en.wikipedia.org/wiki/Order_statistic_tree</link>
                <answer>Supports rank() and select() in O(log n) time.</answer>.
            </question>

            <question id="datastructures-uses-finger-search-tree">
                <text>Finger Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Finger_search_tree</link>
                <answer>Allows fast search to nearby keys, in O(log(rank(x) - rank(y))) time.</answer>.
            </question>
            -->

            <question id="datastructures-uses-heap">
                <text>Heap</text>
                <link>https://en.wikipedia.org/wiki/Heap_(data_structure)</link>
                <answer>Dijkstra's shortest-path algorithm. Prim's minimum spanning tree algorithm. Running Median.</answer>
            </question>

            <!-- Don't bother mentioning uses of binary heaps as well as uses of generic heaps.
            <question id="datastructures-uses-binary-heap">
                <text>Binary Heap</text>
                <link>https://en.wikipedia.org/wiki/Binary_heap</link>
                <answer>Dijkstra's shortest-path algorithm. Prim's minimum spanning tree algorithm. Running Median.</answer>
            </question>
            -->

            <!--
            <question id="datastructures-uses-binomial-heap">
                <text>Binomial Heap</text>
                <link>https://en.wikipedia.org/wiki/Binomial_heap</link>
                <answer>A mergeable heap, implemented as a collection of binomial trees.</answer>
            </question>
            -->

            <question id="datastructures-uses-fibonacci-heap">
                <text>Fibonacci Heap</text>
                <link>https://en.wikipedia.org/wiki/Fibonacci_heap</link>
                <answer>Dijkstra's shortest-path algorithm.</answer>
            </question>

            <!--
            <question id="datastructures-uses-treap">
                <text>Treap</text>
                <link>https://en.wikipedia.org/wiki/Treap</link>
                <answer>A self-balancing binary search tree that is also a min (or max) heap in terms of a random weight for each node, resulting in a random binary search tree that is likely to be balanced.</answer>
            </question>
            -->

            <question id="datastructures-uses-bloom-filter">
                <text>Bloom Filter</text>
                <link>https://en.wikipedia.org/wiki/Bloom_filter</link>
                <answer>Quick filtering where false positives are acceptable. For instance, web cache filtering.</answer>
            </question>

            <question id="datastructures-uses-union-find">
                <text>Union Find (Disjoint Set)</text>
                <link>https://en.wikipedia.org/wiki/Disjoint-set_data_structure</link>
                <answer>Kruskal's minimum spanning tree algorithm. Connected-component Labeling. Detecting a cycle in an undirected graph.</answer>
            </question>

            <!--
            <question id="datastructures-uses-adjacency-list">
                <text>Adjacency List</text>
                <link>https://en.wikipedia.org/wiki/Adjacency_list</link>
                <answer>Lists nodes and their incident (often only outgoing) edges.</answer>
            </question>

            <question id="datastructures-uses-adjacency-matrix">
                <text>Adjacency Matrix</text>
                <link>https://en.wikipedia.org/wiki/Adjacency_matrix</link>
                <answer>For any 2 nodes, provides the edge, if any, that connects them.</answer>
            </question>
            -->

            <question id="datastructures-uses-singly-linked-list">
                <text>Singly Linked List</text>
                <link>https://en.wikipedia.org/wiki/Linked_list#Singly_linked_list</link>
                <answer>Buckets in a separate chaining hash table.</answer>
            </question>

            <question id="datastructures-uses-doubly-linked-list">
                <text>Doubly Linked List</text>
                <link>https://en.wikipedia.org/wiki/Doubly_linked_list</link>
                <answer>An LRU cache. Implement the cache with a doubly-linked list as a queue, and store pointers to the nodes in the hash table. Old items can be removed from the end of the queue, or items can be moved to the head of the queue, via that node pointer</answer>
            </question>

            <question id="datastructures-uses-hash-table">
                <text>Hash Table</text>
                <link>https://en.wikipedia.org/wiki/Hash_table</link>
                <answer>The 2-sum and 3-sum problems. std::unordered_map.</answer>
                <!-- See http://algs4.cs.princeton.edu/14analysis/ for 2-sum and 3-sum. -->
            </question>

            <question id="datastructures-uses-skip-list">
                <text>Skip List</text>
                <link>https://en.wikipedia.org/wiki/Skip_list</link>
                <answer>Database indexing.</answer>
            </question>

            <!--
            <question id="datastructures-uses-splay-tree">
                <text>Splay Tree</text>
                <link>https://en.wikipedia.org/wiki/Splay_tree</link>
                <answer>Binary Search Tree that optimizes itself for recently accessed elements.</answer>
            </question>

            <question id="datastructures-uses-k-d-tree">
                <text>k-d Tree</text>
                <link>https://en.wikipedia.org/wiki/K-d_tree</link>
                <answer>Allows proximity search in k-dimensional data by partitioning the space.</answer>
            </question>
            -->

            <!-- See Sedgewick's summary: https://youtu.be/NeU3SY21aMA?t=7m50s
            TODO: Rephrase this as coding problems.-->
            <question id="datastructures-uses-bst">
                <text>Binary Search Tree</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree</link>
                <answer>Range search over points. For instance, finding points in a line that are in a range.</answer>
                <note>To find intersections of horizontal and vertical line segments, sort the start and end points of the horizontal lines, then sweep horizontally, maintaining a BST of horizontal points, allowing a range search according to any vertical line encountered.</note>
            </question>

            <question id="datastructures-uses-k-d-tree">
                <text>k-d Tree</text>
                <link>https://en.wikipedia.org/wiki/K-d_tree</link>
                <answer>Find points in a plane that are contained by a rectangular range.</answer>
            </question>

            <question id="datastructures-uses-interval-tree">
                <text>Interval Tree</text>
                <link>https://en.wikipedia.org/wiki/Interval_tree</link>
                <answer>Intersection search over intervals. For instance, finding lines in a line that intersect with a range.</answer>
                <note>To find intersections of rectangles, sort the start and end points of the rectangles, then sweep horizontally, maintaining an interval tree of horizontal points, allowing a range search according to any vertical line encountered.</note>
            </question>
    </section>

    <section id="datastructures-linked-list-operations">
        <title>Linked List Operations</title>

        <question id="datastructures-linked-list-operations-sort-">
            <text>Best sort algorithm</text>
            <choices>
                <choice>Mergesort</choice>
                <choice>Quicksort</choice>
            </choices>
            <answer>Mergesort</answer>
            <note>Mergesort has guaranteed O(n log(n)) time. Quicksort only has that with a random choice of pivot, but that is not possible without random access.</note>
        </question>
    </section>


    <section id="datastructures-tree-operations" and_reverse="true">
        <title>Tree Operations</title>

        <subsection id="datastructures-tree-operations-bst-traversal" answers_as_choices="true">
            <title>Traversal</title>
            <link>https://en.wikipedia.org/wiki/Tree_traversal</link>

            <question id="datastructures-tree-operations-pre-order-traversal">
                <text>Pre-Order Traversal</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Pre-order</link>
                <answer>List the nodes first from the root down the left to the leaf, then back up from left to right.</answer>
            </question>

            <question id="datastructures-tree-operations-in-order-traversal">
                <text>In-Order Traversal</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#In-order</link>
                <answer>Lists the items in sorted order (for a BST).</answer>
            </question>

            <question id="datastructures-tree-operations-post-order-traversal">
                <text>Post-Order Traversal</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Post-order</link>
                <answer>List the nodes from the bottom of each path up to the root, listing shared nodes last, from left to right.</answer>
            </question>
        </subsection>

        <subsection id="datastructures-tree-operations-traversal-roots-position" answers_as_choices="true">
            <title>Traversal: Positions of roots</title>
            <link>https://en.wikipedia.org/wiki/Binary_search_tree#Operations</link>

            <question id="datastructures-tree-operations-pre-order-traversal-roots-position">
                <text>Pre-Order Traversal</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Pre-order</link>
                <answer>Roots appear first.</answer>
            </question>

            <question id="datastructures-tree-operations-in-order-traversal-roots-position">
                <text>In-Order Traversal</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#In-order</link>
                <answer>Roots appear in order (for a BST).</answer>
            </question>

            <question id="datastructures-tree-operations-post-order-traversal-roots-position">
                <text>Post-Order Traversal</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Post-order</link>
                <answer>Roots appear last.</answer>
            </question>
        </subsection>

        <subsection id="datastructures-tree-operations-construction-from-traversal" answers_as_choices="true">
            <title>Construction from traversals (generic trees, not BSTs), assuming distinct keys.</title>

            <question id="datastructures-tree-operations-construction-from-preorder-and-inorder">
                <text>From a pre-order traversal and an inorder traversal.</text>
                <link>http://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/</link>
                <answer>Build a hash table mapping values to their positions in the inorder traversal. Recurse, passing the full range for both inorder and preorder traversals. Use the first preorder item as the root. Find that value's position in the inorder traversal, which lets us discover the sizes of the left and right trees to either side of it in the range. The same values are in the preorder after the root item: first the left items and then the right items. Build the left and right trees by recursing, passing these new ranges for inorder and postorder.</answer>
                <note>The pre-order traversal lets us know the root value and that lets us know the subtree sizes.</note>
            </question>

            <question id="datastructures-tree-operations-construction-from-postorder-and-inorder">
                <text>From a post-order traversal and an in-order traversal.</text>
                <link>http://www.geeksforgeeks.org/construct-a-binary-tree-from-postorder-and-inorder/</link>
                <answer>Build a hash table mapping values to their positions in the inorder traversal. Recurse, passing the full range for both inorder and postorder traversals. Use the last postorder item as the root. Find that value's position in the inorder traversal, which lets us discover the sizes of the left and right trees to either side of it in the range. The same values are in the postorder before the root item: first the left items and then the right items. Build the left and right trees by recursing, passing these new ranges for inorder and postorder.</answer>
                <note>The post-order traversal lets us know the root value and that lets us know the subtree sizes.</note>
            </question>

            <question id="datastructures-tree-operations-construction-from-inorder-of-cartesian-tree">
                <text>From an in-order traversal of a cartesian tree.</text>
                <link></link>
                <answer>Build a hash table mapping values to their positions in the inorder traversal. Recurse, passing the full range. Use the item with the maximum value as the root. Find that value's position in the inorder traversal, which lets us discover the sizes of the left and right trees to either side of it in the range. Build the left and right trees by recursing, passing these new ranges.</answer>
                <note>The cartesian tree's max-heap property lets us know the root value and that lets us know the subtree sizes.</note>
            </question>
        </subsection>

        <subsection id="datastructures-tree-operations-bst-construction-from-traversal" answers_as_choices="true">
            <title>Binary Search Tree: Construction from traversals in linear time.</title>

            <question id="datastructures-tree-operations-bst-construction-from-preorder">
                <text>From a pre-order traversal.</text>
                <link>http://www.geeksforgeeks.org/construct-bst-from-given-preorder-traversa/</link>
                <answer>Recursively build. Use the first item as the root if it is within the expected min/max (and advance), then build the left tree, using the root to specify its min/max (and advance), then build the right tree, using the root to specify its min/max (and advance).</answer>
            </question>

            <question id="datastructures-tree-operations-bst-construction-from-inorder">
                <text>From an in-order traversal.</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#In-order</link>
                <answer>Discover the overall count. Then recursively build the left tree (and advance), then the root (and advance), then the right tree (and advance). By halving the count each time, and subtracting 1 for the root.</answer>
                <note>This technique proceeds regularly through the array, so it is also suitable for a linked list.</note>
            </question>

            <question id="datastructures-tree-operations-bst-construction-from-postorder">
                <text>From a post-order traversal.</text>
                <link>http://www.geeksforgeeks.org/construct-a-binary-search-tree-from-given-postorder/</link>
                <answer>Discover the overall count. Recursively build. Use the last item as the root (and advance the root pointer backwards), then build the left tree, using the root to specify its min/max (and advance the main pointer forwards), then build the right tree, using the root to specify its min/max (and advance the main pointer forwards).</answer>
            </question>
        </subsection>

        <subsection id="datastructures-tree-operations-bst-others" answers_as_choices="true">
            <title>Binary Search Tree: Others</title>
            <link>https://en.wikipedia.org/wiki/Binary_search_tree#Operations</link>

            <question id="datastructures-tree-operations-bst-search">
                <text>Search</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Searching</link>
                <answer>Find the node by comparing its key.</answer>
            </question>

            <question id="datastructures-tree-operations-bst-successor">
                <text>Successor</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Searching</link>
                <answer>Find the node with the next key in order.</answer>
            </question>

            <question id="datastructures-tree-operations-bst-predecessor">
                <text>Predecessor</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree</link>
                <answer>Find the node with the previous key in order.</answer>
            </question>

            <question id="datastructures-tree-operations-bst-insert">
                <text>Insert</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Insertion</link>
                <answer>Add a node with the specified key.</answer>
            </question>

            <question id="datastructures-tree-operations-bst-delete">
                <text>Delete</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Deletion</link>
                <answer>Remove a node with the specified key.</answer>
            </question>
        </subsection>

        <subsection id="datastructures-tree-implementation-bst-traversal" answers_as_choices="true">
            <title>Binary Search Tree: Implementations: Traversal</title>
            <link>https://en.wikipedia.org/wiki/Binary_search_tree#Operations</link>

            <question id="datastructures-tree-implementation-bst-pre-order-traversal-recursive">
                <text>Pre-Order Traversal (Recursive)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Pre-order</link>
                <answer>Use the current node, recurse into left tree, recurse into right tree.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-pre-order-traversal-iterative">
                <text>Pre-Order Traversal (Iterative)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Pre-order</link>
                <answer>Put root on stack. while(stack not empty), take from stack, use current node, put right then left on stack.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-pre-order-traversal-morris">
                <text>Pre-Order Traversal (Morris Traversal)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Morris_in-order_traversal_using_threading</link>
                <answer>If there is no left child, use the current node and go right (possibly using a temporary right link to reach an ancestor successor). If there is a left child, find the predecessor (left child's rightmost node). Set a temporary right link from that predecessor to the current node (its successor), use the current node, and go left. But if the temporary link already exists, clear it and go right.</answer>
                <video>https://youtu.be/wGXB9OWhPTg?t=1m22s</video>
            </question>

            <question id="datastructures-tree-implementation-bst-in-order-traversal-recursive">
                <text>In-Order Traversal (Recursive)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#In-order</link>
                <answer>Recurse into left tree, use the current node, recurse into right tree.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-in-order-traversal-iterative">
                <text>In-Order Traversal (Iterative)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#In-order</link>
                <answer>While(stack not empty), while(current is null), travel leftwards, adding nodes to the stack. Pop and use the left-most node. Put the right node on the stack and set it as current.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-in-order-traversal-morris">
                <text>In-Order Traversal (Morris Traversal)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Morris_in-order_traversal_using_threading</link>
                <answer>If there is no left child, use the current node and go right (possibly using a temporary right link to reach an ancestor successor). If there is a left child, find the predecessor (left child's rightmost node). Set a temporary right link from that predecessor to the current node (its successor) and go left. But if the temporary link already exists, clear it, use the current node, and go right.</answer>
                <video>https://youtu.be/wGXB9OWhPTg?t=1m22s</video>
            </question>

            <question id="datastructures-tree-implementation-bst-post-order-traversal-recursive">
                <text>Post-Order Traversal (Recursive)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Post-order</link>
                <answer>Recurse into left tree, recurse into right tree, use the current node.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-post-order-traversal-iterative">
                <text>Post-Order Traversal (Iterative)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Post-order</link>
                <answer>Use 2 stacks. Put root on stack1. while(stack1 not empty), take from stack1, put on stack2, put left and right on stack1. while(stack2 not empty), take from stack and use.  Alternatively, modify the pre-order algorithm, to reverse the order of putting the children on the stack, then reverse the whole result at the end.</answer>
            </question>

            <!-- TODO: See https://www.quora.com/What-is-a-good-way-to-implement-stackless-recursion-less-post-order-traversal-for-a-non-threaded-binary-tree-using-Morris-method
            <question id="datastructures-tree-implementation-bst-post-order-traversal-morris">
                <text>Post-Order Traversal (Morris Traversal)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Morris_in-order_traversal_using_threading</link>
                <answer>TODO</answer>
            </question>
            -->

            <question id="datastructures-tree-implementation-bst-level-order-traversal-iterative">
                <text>Level-Order Traversal (BFS) (Iterative)</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search_2</link>
                <answer>Add root to a queue. While(queue not empty), pop a node from the queue, use it, add left to the queue, add right to the queue.</answer>
            </question>
        </subsection>

        <subsection id="datastructures-tree-implementation-bst-others" answers_as_choices="true">
            <title>Binary Search Tree: Implementations: Other</title>
            <link>https://en.wikipedia.org/wiki/Binary_search_tree#Operations</link>

            <question id="datastructures-tree-implementation-bst-search">
                <text>Search</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Searching</link>
                <answer>Compare with root's key and then search in the left or right subtree, comparing each node's key and then going left or right.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-successor">
                <text>Successor</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Searching</link>
                <answer>Find left-most child of right child. Or if there is no right child, find the nearest ancestor that is an ancestor's left child.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-predecessor">
                <text>Predecessor</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree</link>
                <answer>Find right-most child of left child. Or if there is no left child, find the nearest ancestor that is an ancestor's right child.</answer>
            </question>
            <!-- TODO: recursive and iterative implementations? -->

            <question id="datastructures-tree-implementation-bst-insert">
                <text>Insert</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Insertion</link>
                <answer>Search for the node's key until we find a null child. Put the node in that position.</answer>
            </question>

            <!-- TODO: 2 versions of delete. One changing values, and one moving nodes. Only earlier CLRS versions copied values.
                 For copying values, see wikipedia or http://www.algolist.net/Data_structures/Binary_search_tree/Removal -->
            <question id="datastructures-tree-implementation-bst-delete">
                <text>Delete</text>
                <link>https://en.wikipedia.org/wiki/Binary_search_tree#Deletion</link>
                <answer>If there are 2 child nodes: Find the successor. If there is no successor then there is no right child, so replace the node with the left child. If there is a successor, replace the node with the successor, making the node's left child be the successor's left node, making the successor's original parent be the successor's right child and making the successor's original right child be the successor's original parent's left child.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-left-rotation">
                <text>Left Rotation</text>
                <link>https://en.wikipedia.org/wiki/Tree_rotation</link>
                <answer>The node's right child becomes its parent, with the node as the left child. The right child's left child becomes the node's right child.</answer>
            </question>

            <question id="datastructures-tree-implementation-bst-right-rotation">
                <text>Right Rotation</text>
                <link>https://en.wikipedia.org/wiki/Tree_rotation</link>
                <answer>The node's left child becomes its parent, with the node as the right child. The left child's right child becomes the node's left child.</answer>
            </question>

            <!-- TODO: BST Order/Rank. -->

        </subsection>

        <subsection id="datastructures-tree-operations-uses-bst-traversal" answers_as_choices="true">
            <title>Binary Search Tree: Traversal Uses</title>
            <link>https://en.wikipedia.org/wiki/Binary_search_tree#Operations</link>

            <question id="datastructures-tree-operations-bst-pre-order-traversal">
                <text>Pre-Order Traversal</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Pre-order</link>
                <answer>Duplicate the tree. Generate a prefix representation of an expression tree.</answer>
            </question>

            <question id="datastructures-tree-operations-bst-in-order-traversal">
                <text>In-Order Traversal</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#In-order</link>
                <answer>List the nodes in order.</answer>
            </question>

            <question id="datastructures-tree-operations-bst-post-order-traversal">
                <text>Post-Order Traversal</text>
                <link>https://en.wikipedia.org/wiki/Tree_traversal#Post-order</link>
                <answer>Delete the entire tree, by deleting children before parents. Generate a postfix representation of an expression tree.</answer>
            </question>
        </subsection>

        <subsection id="datastructures-tree-lca-and-rmq" answers_as_choices="true">
            <title>LCA (Lowest Common Ancestor) and RMQ (Range Minimum Query) Reduction</title>
            <link>https://www.topcoder.com/community/data-science/data-science-tutorials/range-minimum-query-and-lowest-common-ancestor/</link>

            <question id="datastructures-tree-lca-and-rmq-lca">
                <text>LCA via RMQ</text>
                <link>https://www.topcoder.com/community/data-science/data-science-tutorials/range-minimum-query-and-lowest-common-ancestor/#Reduction%20from%20LCA%20to%20RMQ</link>
                <answer>Build the Euler tour of the tree, storing the level of each node visited and storing the first occurrence of each node. Do RMQ on the levels array in the range defined by the first appearances of each node. Then use the index of the RMQ to find the node in the Euler tour.</answer>
                <video_url>https://www.youtube.com/watch?v=0rCFkuQS968</video_url>
            </question>

            <question id="datastructures-tree-lca-and-lca-rmq">
                <text>RMQ via LCA</text>
                <link>https://www.topcoder.com/community/data-science/data-science-tutorials/range-minimum-query-and-lowest-common-ancestor/#From%20RMQ%20to%20LCA</link>
                <answer>Build a Cartesian Tree of the array. The LCA of nodes in this tree is the RMQ of the values in the array.</answer>
                <video_url>https://www.youtube.com/watch?v=0rCFkuQS968</video_url>
            </question>
        </subsection>
    </section>


    <section id="datastructures-hash-tables" and_reverse="true">
        <title>Hash Tables</title>
        <link>https://en.wikipedia.org/wiki/Hash_table</link>

        <subsection id="datastructures-hash-tables-collision-resolution" answers_as_choices="true">
            <title>Collision Resolution</title>
            <link>https://en.wikipedia.org/wiki/Hash_table#Collision_resolution</link>

            <question id="datastructures-hash-tables-collision-resolution-chaining">
                <text>Separate chaining (open hashing)</text>
                <link>https://en.wikipedia.org/wiki/Hash_table#Separate_chaining</link>
                <answer>Each bucket is independent, and has a list of entries with the same index.</answer>
                <note>In a concurrent hash table, each list could have its own lock.</note>
            </question>

            <question id="datastructures-hash-tables-collision-resolution-open-addressing">
                <text>Open addressing (closed hashing)</text>
                <link>https://en.wikipedia.org/wiki/Hash_table#Open_addressing</link>
                <answer>All entry records are stored in the bucket array itself. Lookups may examine a series of buckets.</answer>
            </question>

            <question id="datastructures-hash-tables-collision-resolution-robin-hood-hashing">
                <text>Robin Hood hashing</text>
                <link>https://en.wikipedia.org/wiki/Hash_table#Robin_Hood_hashing</link>
                <answer>A key will be relocated if its probe count is higher than for the new key.</answer>
            </question>

            <question id="datastructures-hash-tables-collision-resolution-2-choice-hashing">
                <text>2-choice hashing</text>
                <link>https://en.wikipedia.org/wiki/2-choice_hashing</link>
                <answer>2 hash functions provide 2 potential positions for a key. The key is placed where there would be fewer collisions.</answer>
            </question>
        </subsection>

        <!-- TODO: Need to find better advantages/disadvantages for these. -->
        <subsection id="datastructures-hash-tables-collision-resolution-advantages" answers_as_choices="true">
            <title>Collision Resolution: Advantages/Disadvantages</title>
            <link>https://en.wikipedia.org/wiki/Hash_table#Collision_resolution</link>

            <question id="datastructures-hash-tables-collision-resolution-advantages-chaining">
                <text>Separate chaining (open hashing)</text>
                <link>https://en.wikipedia.org/wiki/Hash_table#Separate_chaining</link>
                <answer>Advantages: Simple implementation. Avoids rehashing. Each list can have its own lock in a concurrent hash table. Disadvantage: Pointer chasing causes cache misses. Extra space.</answer>
            </question>

            <question id="datastructures-hash-tables-collision-resolution-advantages-open-addressing">
                <text>Open addressing (closed hashing)</text>
                <link>https://en.wikipedia.org/wiki/Hash_table#Open_addressing</link>
                <answer>Advantage: Data locality gives good cache performance. Disadvantage: Requires reallocation and rehashing.</answer>
            </question>

            <question id="datastructures-hash-tables-collision-resolution-advantages-robin-hood-hashing">
                <text>Robin Hood hashing</text>
                <link>https://en.wikipedia.org/wiki/Hash_table#Robin_Hood_hashing</link>
                <answer>Advantage: Reduces worst case search times.</answer>
            </question>

            <!-- TODO:
            <question id="datastructures-hash-tables-collision-resolution-advantages-2-choice-hashing">
                <text>2-choice hashing</text>
                <link>https://en.wikipedia.org/wiki/2-choice_hashing</link>
                <answer>TODO</answer>
            </question>
            -->
        </subsection>

        <subsection id="datastructures-hash-tables-open-addressing-strategies" answers_as_choices="true">
            <title>Open addressing strategies</title>
            <link>https://en.wikipedia.org/wiki/Open_addressing</link>

            <question id="datastructures-hash-tables-open-addressing-strategy-probe-sequence">
                <text>Probe sequence</text>
                <link>https://en.wikipedia.org/wiki/Open_addressing</link>
                <answer>The buckets are examined, starting with the hashed-to slot and proceeding in some probe sequence, until an unoccupied slot is found.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-strategy-coalesced-hashing">
                <text>Coalesced hashing</text>
                <link>https://en.wikipedia.org/wiki/Coalesced_hashing</link>
                <answer>Hybrid of separate chaining and open addressing, chaining from filled buckets to unused buckets.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-strategy-cuckoo-hashing">
                <text>Cuckoo hashing</text>
                <link>https://en.wikipedia.org/wiki/Cuckoo_hashing</link>
                <answer>The key is re-hashed with other hash functions to find an empty bucket. (All hashes may be tried during lookup.) If all collide, the existing key is re-hashed, possibly causing further re-hashing. If this eventually fails, the table is resized.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-strategy-hopscotch-hashing">
                <text>Hopscotch hashing</text>
                <link>https://en.wikipedia.org/wiki/Hopscotch_hashing</link>
                <answer>The key is always in the neighborhood of the original bucket. If necessary, existing items are moved, though without moving them outside of their neighbourhoods.</answer>
                <note>This is suitable for a concurrent hash table because neighbourhoods can be locked individually, instead of having one lock on the whole table.</note>
            </question>
        </subsection>

        <!-- TODO: Need to find better advantages/disadvantages for these. -->
        <subsection id="datastructures-hash-tables-open-addressing-strategies-advantages" answers_as_choices="true">
            <title>Open addressing strategies: Advantages</title>
            <link>https://en.wikipedia.org/wiki/Open_addressing</link>

            <question id="datastructures-hash-tables-open-addressing-strategy-advantage-probe-sequence">
                <text>Probe sequence</text>
                <link>https://en.wikipedia.org/wiki/Open_addressing</link>
                <answer>Fast insertion and fast search.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-strategy-advantage-coalesced-hashing">
                <text>Coalesced hashing</text>
                <link>https://en.wikipedia.org/wiki/Coalesced_hashing</link>
                <answer>No clustering effects; in fact, the table can be efficiently filled to a high density.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-strategy-advantage-cuckoo-hashing">
                <text>Cuckoo hashing</text>
                <link>https://en.wikipedia.org/wiki/Cuckoo_hashing</link>
                <answer>Constant lookup time in the worst case, and constant amortized time for insertions and deletions.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-strategy-advantage-hopscotch-hashing">
                <text>Hopscotch hashing</text>
                <link>https://en.wikipedia.org/wiki/Hopscotch_hashing</link>
                <answer>Works well even when the load factor grows beyond 0.9. Allows use of simple hash function. Neighbourhoods can be locked separately in a concurrent hash table.</answer>
            </question>
        </subsection>

        <!-- TODO: Deletion in open addressing and coalesced hashing: Use of sentinel. -->
        <!-- TODO: Good load factor. -->

        <subsection id="datastructures-hash-tables-open-addressing-probing" answers_as_choices="true">
            <title>Open addressing probe sequences: Description</title>
            <link>https://en.wikipedia.org/wiki/Open_addressing</link>

            <question id="datastructures-hash-tables-open-addressing-probing-linear-probing">
                <text>Linear probing</text>
                <link>https://en.wikipedia.org/wiki/Linear_probing</link>
                <answer>The interval between probes is fixed — often at 1.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-probing-quadratic-probing">
                <text>Quadratic probing</text>
                <link>https://en.wikipedia.org/wiki/Quadratic_probing</link>
                <answer>The interval between probes increases linearly (the indices are described by a quadratic function).</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-probing-double-hashing">
                <text>Double hashing</text>
                <link>https://en.wikipedia.org/wiki/Double_hashing</link>
                <answer>The interval between probes is computed by another hash function.</answer>
            </question>
        </subsection>

        <subsection id="datastructures-hash-tables-open-addressing-probing-advantages" answers_as_choices="true">
            <title>Open addressing probe sequences: Advantages/Disadvantages</title>
            <link>https://en.wikipedia.org/wiki/Open_addressing</link>

            <question id="datastructures-hash-tables-open-addressing-probing-advantage-linear-probing">
                <text>Linear probing</text>
                <link>https://en.wikipedia.org/wiki/Linear_probing</link>
                <answer>Advantage: best cache performance. Disadvantage: worst clustering.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-probing-advantage-quadratic-probing">
                <text>Quadratic probing</text>
                <link>https://en.wikipedia.org/wiki/Quadratic_probing</link>
                <answer>Advantage: good cache performance and minimal clustering.</answer>
            </question>

            <question id="datastructures-hash-tables-open-addressing-probing-advantage-double-hashing">
                <text>Double hashing</text>
                <link>https://en.wikipedia.org/wiki/Double_hashing</link>
                <answer>Advantage: no clustering. Disadvantage: worst cache performance.</answer>
            </question>
        </subsection>

        <!-- TODO: Best data structure for string searches:
        See page 752 of Sedgewick's Algorithms book:
        Binary Search Tree: Randomly ordered keys.
        Red-Black Tree: Guaranteed performance.
        Hash Table (Open Addressing): ?
        Trie: Short keys and small alphabets.
        Ternary Search Tree (TST): Non-random keys.

        Suffix tree / suffix array: sub-strings (not just from the start of the string).
        -->

        <!-- TODO: Load factor definition: = n/m. -->

        <!-- Open Addressing methods:
        last-come first served hashing
        cuckoo hashing -->

        <!-- TODO: Hash functions
        https://en.wikipedia.org/wiki/Category:Hash_function_(non-cryptographic)
        https://en.wikipedia.org/wiki/Jenkins_hash_function#one-at-a-time
        https://en.wikipedia.org/wiki/CityHash
        https://en.wikipedia.org/wiki/Fowler_Noll_Vo_hash
        https://en.wikipedia.org/wiki/MurmurHash
        https://en.wikipedia.org/wiki/Jenkins_hash_function
        https://en.wikipedia.org/wiki/HighwayHash
        https://en.wikipedia.org/wiki/Java_hashCode()
        https://en.wikipedia.org/wiki/Pearson_hashing
        https://en.wikipedia.org/wiki/PJW_hash_function
        -->

    </section>


    <!-- Probabilistic data structures?
         https://en.wikipedia.org/wiki/Category:Probabilistic_data_structures
    -->

    <!-- What data structure to use for problem:
    Set membership, allowing some mistakes: Bloom filter.
    Set membership, allowing fast testing, membership changing ,and set unioning: Union-Find.

    Sedgewick: https://youtu.be/fJe11uNfLJw?list=PLrNmXMVD0XDSBFQZk48NfzLO1MWxhXZEB&t=41 :
    Dynamic Connectivity: Union-Find
    LCA: Union-Find: https://en.wikipedia.org/wiki/Tarjan%27s_off-line_lowest_common_ancestors_algorithm
    Percolation: Union-Find
    Kruskal's MST: Union-Find

    Sparse Graph: Adjacency List
    Dense Graph: Adjacency Matrix

    Singly Linked List
    Doubly Linked List

    Trie (AKA PrefixTree): Text prediction using prefixes. Associative store where the keys share prefixes.
    Radix Tree: IP Routing (Longest Prefix Matching), Inverted Indices
    Suffix Tree: Find longest repeated substring: https://en.wikipedia.org/wiki/Longest_repeated_substring_problem
      Find longest common substring: https://en.wikipedia.org/wiki/Longest_common_substring_problem
      (Can also be done with dynamic programming)
      Find longest palindrome.
    Tree
    Binary Search Tree
    Balanced Binary Tree (advantages of AVL, Red/Black, etc)
    Optimal Binary Search Tree: Access most frequently queried items faster.
    B-Tree: ? To minimize Disk I/O. Optimized for reading and writing large blocks of data - better data locality. Also when it takes longer to access the nodes than to use the obtained data, for instance when the data is on disk.
    Van de Boas Tree: Data locality?
    Skip List
    Heap (AKA Priority Queue) (advantages of different implementations, including Fibonacci Heap)
    Treap?
    Splay Tree: Access recently-queried items faster.
    K-D Tree: Find neighbours in a K-Dimensional space.
    -->

    <!-- Operations on data structures:
    Linked List: Find cycle: Slow and Fast stepping.
    Union-Find: Join a group: Set to same parent.
    -->


    <!-- Longest Common Subsequence: https://en.wikipedia.org/wiki/Longest_common_subsequence_problem -->
    <!-- TODO: https://en.wikipedia.org/wiki/Category:Problems_on_strings -->

</quiz>
